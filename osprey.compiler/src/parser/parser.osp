/************************************************************
 * This directory contains the parser and tokenizer code.   *
 ************************************************************/

use "ContextualType.osp";
use "Lexer.osp";
use "LexerFlags.osp";
use "LexicalFacts.osp";
use "Modifiers.osp";
use "ParserErrorManager.osp";
use "ParseFlags.osp";
use "ParserBase.osp";
use "Token.osp";
use "TokenType.osp";
// ParseError is defined in errors/ParseError.osp

// We can't put osprey.compiler.Parser in its own file, because of Windows.

use aves;
use osprey.compiler.syntax;

namespace osprey.compiler.parser;

/// Summary: Parses Osprey source code into a parse tree, by examining a stream of tokens
///          produced by a {Lexer}. The parser can parse structures starting at any index
///          in the token stream. Typically, the {parseDocument} method is used to parse
///          an entire source file.
public inheritable Parser is ParserBase
{
	/// Summary: Creates a new {Parser} with the specified source file and default flags.
	/// Param source: A {SourceFile} or {Lexer} that contains the code to parse.
	/// Throws ArgumentTypeError:
	///          {source} is not a {SourceFile} or {Lexer}.
	public new(source)
	{
		new base(source, ParseFlags.none, null);
	}
	/// Summary: Creates a new {Parser} with the specified source file and flags.
	/// Param source: A {SourceFile} or {Lexer} that contains the code to parse.
	/// Param flags:  A {ParseFlags} value that specifies parser options.
	/// Throws ArgumentTypeError:
	///          {source} is not a {SourceFile} or {Lexer}.
	///
	///          {flags} is not a {ParseFlags}.
	public new(source, flags)
	{
		new base(source, flags, null);
	}
	/// Summary: Creates a new {Parser} with the specified source file, flags and error
	///          manager.
	/// Param source:       A {SourceFile} or {Lexer} that contains the code to parse.
	/// Param flags:        A {ParseFlags} value that specifies parser options.
	/// Param errorManager: An {ErrorManager} that receives recoverable parse errors.
	///                     If this parameter is null, the parser creates its own error
	///                     manager, which throws all errors.
	/// Remarks: The {ErrorManager} only receives recoverable errors. Fatal parse errors,
	///          such as invalid syntax, are always thrown. The {ErrorManager} is passed
	///          on to the lexer that the parse creates if {source} is a {SourceFile}. If
	///          {source} is already a {Lexer}, its error manager is used as-is.
	/// Throws ArgumentTypeError:
	///          {source} is not a {SourceFile} or {Lexer}.
	///
	///          {flags} is not a {ParseFlags}.
	///
	///          {errorManager} is not null or an {ErrorManager}.
	public new(source, flags, errorManager)
	{
		new base(source, flags, errorManager);
	}

	/// Summary: Determines whether the specified {Expression} is classified as
	///          assignable.
	/// Returns: True if {expression} is classified as assignable; otherwise, false.
	public isAssignable(expression)
	{
		return expression is SimpleNameExpression
			or expression is MemberAccessExpression
			or expression is IndexerAccessExpression
			or expression is GlobalAccessExpression;
	}

	/// Summary: Ensures that the specified {Expression} is classified as assignable.
	///          If the expression is not assignable, a recoverable error is triggered.
	/// Param errorCode: The error code that is associated with the error thrown if
	///          {expression} is not assignable.
	public ensureAssignable(expression, errorCode = null)
	{
		if not isAssignable(expression):
			recoverableError(expression, errorCode ?? ErrorCode.err_ExpressionMustBeAssignable);
	}

	/// Summary: Determines whether the specified {Expression} is a valid statement-expression.
	/// Returns: True if {expression} is a valid statement-expression; otherwise, false.
	public isStatementExpression(expression)
	{
		/* From the grammar:
		 *   statement-expression:
		 *     invocation-expression
		 *     function-application-expression
		 *     object-creation-expression
		 *     A safe-access whose last safe-access-link (if it has a safe-access-chain)
		 *       or whose safe-start-component (if it does not) is a safe-invocation or
		 *       unsafe-invocation
		 */
		if expression is BinaryExpression:
			return expression.op == BinaryOperator.functionApplication;

		if expression is SafeAccessExpression:
			return expression.chain.last() is SafeInvocation;

		return expression is InvocationExpression or
			expression is ObjectCreationExpression;
	}

	/*\
	|*| In all the parse methods below, every single method that doesn't just directly
	|*| call another method should have a description of the grammar it parses. This is
	|*| partly for your reference as you write the method, partly for the benefit of
	|*| anyone who has to read the code.
	|*|
	|*| Your comment should use the same basic structure as the Osprey grammar, with
	|*| the following rules:
	|*|   1. Nonterminal symbols are unquoted. Ex: qualified-name, null-or-expression,
	|*|      statement.
	|*|   2. Terminal symbols are quoted with single quotes. Use \ to escape embedded
	|*|      single quotes and backslashes (should generally not be necessary). Other
	|*|      escape-sequence-looking sequences are verbatim (e.g. '\t' means backslash
	|*|      followed by t, not tab). Ex: 'inheritable', 'with', ':', '<=>'.
	|*|   3. Optional symbols are followed by a question mark, not "_opt". This is
	|*|      mainly for brevity. Do not surround optional symbols in square brackets.
	|*|   4. Do not abbreviate nonterminal symbol names: it must be possible to search
	|*|      the grammar document and this source code for their definitions. If you
	|*|      must break a definition into multiple lines, indent subsequent lines by
	|*|      two (2) spaces.
	|*|   5. Do feel free to align terminal symbols in 'one of' definitions into neat-
	|*|      looking tables if it improves legibility. Align with spaces, never tabs.
	|*|   6. Define only the symbols your code parses fully. If you call `accept` only
	|*|      to determine which kind of symbol to parse, do not define that symbol in
	|*|      your comment. For example, if you `accept` the 'var' keyword to decide
	|*|      whether to parse a variable declaration, do not define the syntax for the
	|*|      variable declaration in your method, but rather in the method that parses
	|*|      the declaration.
	|*|
	|*| The comment is structured and formatted as follows:
	|*|   Syntax:                 <-- "Syntax" header, must be present
	|*|     symbol-one:           <-- nonterminal being defined (indent 2 spaces)
	|*|       foo 'bar' baz       <-- definition line (indent another 2 spaces)
	|*|       one two three?
	|*|         'four'? five      <-- wrapped defintion line (another 2 spaces)
	|*|     symbol-two: one of    <-- definition using 'one of'
	|*|       'p' 'a' 'n' 'd'     <-- no need to indent wrapped lines: every symbol is
	|*|       'i' 'o'                 an expansion of the defined nonterminal
	|*|   Additional notes/restrictions/requirements:
	|*|     Optional plain-text description of additional notes, restrictions or
	|*|     requirements (pick one, or a suitable synonym). This section must always be
	|*|     present when the method deviates from the spec for some reason, such as how
	|*|     default values of optional parameters are parsed using `parseExpression`.
	|*|     Other comments/notes should be put in line with the code, since it usually
	|*|     reads better.
	|*|
	|*| Unless otherwise necessary, prefer using 'start' for the variable that holds the
	|*| token that represents the start of the symbol being parsed. If it is not passed
	|*| as the first argument to `getLocation`, consider using a different name. Also
	|*| why aren't you passing the start token as the first argument to `getLocation`?
	|*|
	|*| If you skip more than one token, or if you do some work in between reading a
	|*| token and skipping it, consider adding a brief comment that explains what you
	|*| are skipping. Something like `// skip name and ':'` is usually fine.
	|*|
	|*| The Osprey grammar is context-free. Therefore, your parse methods should not
	|*| require more than one parameter, the token index, always called `i`. It may be
	|*| okay to accept a `Modifiers` instance if you're parsing a member declaration,
	|*| but make it optional. If you need additional context, you're writing a helper
	|*| method: make it private.
	\*/

	/// Summary: Parses an entire source file, starting at token index 0.
	/// Returns: A {Document} instance representing a parse tree for the source file.
	/// Remarks: This method parses the grammar of the 'compilation-unit' nonterminal.
	public parseDocument()
	{
		var i = 0;
		return parseDocument(ref i);
	}

	/// Summary: Parses an entire source file, starting at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: A {Document} instance representing a parse tree for the source file.
	/// Remarks: This method parses the grammar of the 'compilation-unit' nonterminal.
	public parseDocument(ref i)
	{
		/* Syntax:
		 *   compilation-unit:
		 *     use-directives? global-annotations? file-namespace-declaration?
		 *       top-level-members?
		 *   top-level-members:
		 *     top-level-member
		 *     top-level-members top-level-member
		 *   top-level-member:
		 *     global-statement
		 *     global-variable-declaration ';'
		 *     namespace-member
		 *   global-statement:
		 *     embedded-statement
		 *   global-variable-declaration:
		 *     local-variable-declaration
		 * namespace-member is defined in parseNamespaceMember.
		 */

		var start = lex[i];

		// use-directives
		var uses;
		if accept(i, TokenType.\use):
			uses = parseUseDirectives(ref i);

		var globalAnnotations;
		if accept(i, TokenType.exclam):
			globalAnnotations = parseGlobalAnnotations(ref i);

		// file-namespace-declaration
		var fileNamespace = tryParseFileNamespaceDeclaration(ref i);

		// top-level-members, grouped into global-statements and everything else.
		var members = new List(5), statements = [];
		var modifiers = new Modifiers();
		while not accept(i, TokenType.eof)
		{
			parseModifiers(ref i, modifiers);

			var token = lex[i];
			var construct;
			if token.match(TokenType.\namespace)
			{
				modifiers.verifyForNamespace(this);
				construct = parseNamespaceDeclaration(ref i);
			}
			else if token.match(TokenType.\class) or
				// Class declaration permits 'class' keyword to be omitted
				// if 'inheritable' is the last modifier
				modifiers.\inheritable and modifiers.\inheritable refeq lex[i - 1]
			{
				construct = parseClassDeclaration(ref i, modifiers);
			}
			else if token.match(TokenType.\enum)
			{
				construct = parseEnumDeclaration(ref i, modifiers);
			}
			else if token.match(TokenType.\const)
			{
				construct = parseGlobalConstantDeclaration(ref i, modifiers);
			}
			else if token.match(TokenType.\function)
			{
				construct = parseGlobalFunctionDeclaration(ref i, modifiers);
			}
			else if not modifiers.isEmpty
			{
				fatalError(token, ErrorCode.err_ExpectedNamespaceMember);
			}
			else
			{
				if token.match(TokenType.\var)
				{
					construct = parseLocalVariableDeclaration(ref i);
					construct = new GlobalVariableDeclaration(construct.location, construct);
				}
				else
				{
					construct = parseEmbeddedStatement(ref i);
				}
				statements.add(construct);
				next;
			}
			members.add(construct);
		}
		members = new NodeList(members);
		statements = new NodeList(statements);

		var end = lex[i];
		return new Document(
			getLocation(start, end),
			uses,
			globalAnnotations,
			fileNamespace,
			members,
			statements
		);
	}

	private parseUseDirectives(ref i)
	{
		/* Syntax:
		 *   use-directives:
		 *     use-directive
		 *     use-directives use-directive
		 */
		var uses = new List(2);

		while accept(i, TokenType.\use):
			uses.add(parseUseDirective(ref i));

		return new NodeList(uses);
	}

	/// Summary: Parses a `use` directive at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: A {UseDirective} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'use-directive' nonterminal.
	public parseUseDirective(ref i)
	{
		/* Syntax:
		 *   use-directive:
		 *     use-namespace-directive
		 *     use-file-directive
		 *     use-alias-directive
		 *   use-namespace-directive:
		 *     'use' qualified-name ';'
		 *   use-file-directive:
		 *     'use' string-literal ';'
		 *   use-alias-directive:
		 *     'use' identifier '=' qualified-name ';'
		 */
		var start = expectr(ref i, TokenType.\use);

		if accept(i, TokenType.string)
		{
			// UseFileDirective
			var fileName = lex[i];
			i += 1;
			var end = expectr(ref i, TokenType.semicolon);
			return new UseFileDirective(getLocation(start, end), fileName);
		}

		if accept(i, TokenType.identifier)
		{
			// UseNamespaceDirective or UseAliasDirective: if we find an '=' after
			// the identifier, it must be a member alias; otherwise, we parse it
			// as a UseNamespaceDirective.
			if accept(i + 1, TokenType.assign)
			{
				// UseAliasDirective
				var alias = lex[i];
				i += 2; // skip alias and '='
				var fullName = parseQualifiedName(ref i);
				var end = expectr(ref i, TokenType.semicolon);
				return new UseAliasDirective(getLocation(start, end), alias, fullName);
			}
			else
			{
				// UseNamespaceDirective
				var name = parseQualifiedName(ref i);
				var end = expectr(ref i, TokenType.semicolon);
				return new UseNamespaceDirective(getLocation(start, end), name);
			}
		}

		fatalError(lex[i], ErrorCode.err_InvalidUseDirective);
	}

	/// Summary: Tries to parse a file namespace declaration at the specified token
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: A {QualifiedName} if the document contains a file namespace declaration,
	///          or null otherwise.
	/// Remarks: This method parses the grammar of the 'file-namespace-declaration' nonterminal.
	///
	///          File namespace declarations are optional. If this method fails to parse a file
	///          namespace declaration, {i} will be unchanged, so {parseNamespaceDeclaration}
	///          can handle it correctly. This is done chiefly to reduce code duplication.
	///
	///          This is a helper method for {parseDocument}.
	private tryParseFileNamespaceDeclaration(ref i)
	{
		/* Syntax:
		 *   file-namespace-declaration:
		 *     'namespace' qualified-name ';'
		 */

		// Don't modify i until we have a full file-namespace-declaration
		var k = i;

		if not acceptr(ref k, TokenType.\namespace):
			return null;

		// We have a 'namespace' keyword. Try to parse the beginning of a namespace
		// declaration. If a curly bracket follows the qualified-name, return null
		// and let top-level-members take care of it.
		// Note: the 'namespace' keyword must always be followed by a qualified-name,
		// even in the file-namespace-declaration, so we can use parseQualifiedName
		// here. If the name is invalid for file-namespace-declaration, it would be
		// invalid for a regular namespace-declaration.

		var fileNamespace = parseQualifiedName(ref k);

		if not acceptr(ref k, TokenType.semicolon):
			return null;

		i = k;
		return fileNamespace;
	}

	//<region: Member declarations>

	/// Summary: Parses a namespace declaration at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: A {NamespaceDeclaration} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'namespace-declaration' nonterminal.
	public parseNamespaceDeclaration(ref i)
	{
		/* Syntax:
		 *   namespace-declaration:
		 *     namespace qualified-name namespace-body
		 *   namespace-body:
		 *     '{' namespace-members? '}'
		 *   namespace-members:
		 *     namespace-member
		 *     namespace-members namespace-member
		 *   namespace-member:
		 *     global-constant-declaration
		 *     global-function-declaration
		 *     class-declaration
		 *     enum-declaration
		 *     namespace-declaration
		 */
		var start = expectr(ref i, TokenType.\namespace);

		var name = parseQualifiedName(ref i);
		if accept(i, TokenType.semicolon):
			fatalError(lex[i], ErrorCode.err_InvalidLocationForFileNamespace);
		expectr(ref i, TokenType.curlyOpen);

		var members = new List(5);
		var modifiers = new Modifiers();
		while not accept(i, TokenType.eof, TokenType.curlyClose)
		{
			parseModifiers(ref i, modifiers);

			var token = lex[i];
			var member;
			if token.match(TokenType.\const)
			{
				member = parseGlobalConstantDeclaration(ref i, modifiers);
			}
			else if token.match(TokenType.\function)
			{
				member = parseGlobalFunctionDeclaration(ref i, modifiers);
			}
			else if token.match(TokenType.\class) or
				// Class declaration permits 'class' keyword to be omitted
				// if 'inheritable' is the last modifier
				modifiers.\inheritable and modifiers.\inheritable refeq lex[i - 1]
			{
				member = parseClassDeclaration(ref i, modifiers);
			}
			else if token.match(TokenType.\enum)
			{
				member = parseEnumDeclaration(ref i, modifiers);
			}
			else if token.match(TokenType.\namespace)
			{
				modifiers.verifyForNamespace(this);
				member = parseNamespaceDeclaration(ref i);
			}
			else
			{
				fatalError(token, ErrorCode.err_ExpectedNamespaceMember);
			}

			members.add(member);
		}
		members = new NodeList(members);

		var end = expectr(ref i, TokenType.curlyClose);
		return new NamespaceDeclaration(
			getLocation(start, end),
			name, members
		);
	}

	/// Summary: Parses a global constant declaration at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Param modifiers: (optional) An instance of {Modifiers}, which contains the member
	///          modifiers of the constant declaration, such as an accessibility modifier
	///          or annotations. If null, this method will parse modifiers at {i} by calling
	///          {parseModifiers}.
	/// Returns: A {GlobalConstantDeclaration} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'global-constant-declaration' nonterminal.
	public parseGlobalConstantDeclaration(ref i, modifiers = null)
	{
		/* Syntax:
		 *   global-constant-declaration:
		 *     global-modifier? 'const' constant-declarators ';'
		 *   constant-declarators:
		 *     constant-declarator
		 *     constant-declarators ',' constant-declarator
		 *   constant-declarator:
		 *     identifier '=' constant-expression
		 * Additional notes:
		 *   This is not the only method that parses constant-declarators, due to their
		 *   underwhelming simplicity.
		 */
		if modifiers is null:
			modifiers = parseModifiers(ref i);
		modifiers.verifyForGlobalFunctionOrConstant(this);

		var start = expectr(ref i, TokenType.\const);

		var constants = new List(1);
		do
		{
			var name = expectr(ref i, TokenType.identifier);
			expectr(ref i, TokenType.assign, ErrorCode.err_ConstantWithoutValue);
			var value = parseExpression(ref i);

			constants.add(
				new VariableDeclarator(
					getLocation(name, value),
					name, value
				)
			);
		} while acceptr(ref i, TokenType.comma);
		constants = new NodeList(constants);

		var end = expectr(ref i, TokenType.semicolon);
		return new GlobalConstantDeclaration(
			getLocation(modifiers.start ?? start, end),
			modifiers.annotations,
			modifiers.accessibility,
			constants
		);
	}

	/// Summary: Parses a global function declaration at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Param modifiers: (optional) An instance of {Modifiers}, which contains the member
	///          modifiers of the function declaration, such as an accessibility modifier
	///          or annotations. If null, this method will parse modifiers at {i} by calling
	///          {parseModifiers}.
	/// Returns: A {GlobalFunctionDeclaration} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'global-function-declaration' nonterminal.
	public parseGlobalFunctionDeclaration(ref i, modifiers = null)
	{
		/* Syntax:
		 *   global-function-declaration:
		 *     global-modifier? 'function' identifier '(' parameter-list? ')' block
		 * Additional notes:
		 *   If extensions are in use, the body block can also be an __extern reference.
		 */
		if modifiers is null:
			modifiers = parseModifiers(ref i);
		modifiers.verifyForGlobalFunctionOrConstant(this);

		var start = expectr(ref i, TokenType.\function);
		var name = expectr(ref i, TokenType.identifier);

		expectr(ref i, TokenType.parenOpen);
		var parameters = parseParameterList(ref i);
		expectr(ref i, TokenType.parenClose);

		var body = parseBlockOrExtern(ref i);

		return new GlobalFunctionDeclaration(
			getLocation(modifiers.start ?? start, body),
			modifiers.annotations,
			modifiers.accessibility,
			name,
			parameters,
			body
		);
	}

	/// Summary: Parses a class declaration at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Param modifiers: (optional) An instance of {Modifiers}, which contains the member
	///          modifiers of the class declaration, such as an accessibility modifier or
	///          annotations. If null, this method will parse modifiers at {i} by calling
	///          {parseModifiers}.
	/// Returns: A {ClassDeclaration} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'class-declaration' nonterminal.
	public parseClassDeclaration(ref i, modifiers = null)
	{
		/* Syntax:
		 *   class-declaration:
		 *     annotations? class-modifiers? 'class' identifier class-base? class-body
		 *     annotations? class-modifiers? 'inheritable' identifier class-base? class-body
		 *   class-modifiers:
		 *     class-modifier
		 *     class-modifiers class-modifier
		 *   class-modifier:
		 *     'public'
		 *     'internal'
		 *     'abstract'
		 *     'static'
		 *     'inheritable'
		 *   class-base:
		 *     'is' type
		 *     '__primitive'    (non-standard extension)
		 *   class-body:
		 *     '{' type-initer? class-member-declarations? '}'
		 *   type-initer:       (non-standard extension)
		 *     '__init_type' '(' string-literal ')' ';'
		 */
		if modifiers is null:
			modifiers = parseModifiers(ref i);
		modifiers.verifyForClass(this);

		var start;
		if modifiers.\inheritable and modifiers.\inheritable refeq lex[i - 1]:
			// 'class' keyword is optional if 'inheritable' is the last modifier
			acceptr(ref i, TokenType.\class);
		else:
			start = expectr(ref i, TokenType.\class);
		start = modifiers.start ?? start;

		var name = expectr(ref i, TokenType.identifier);

		var baseType;
		if acceptr(ref i, TokenType.\is):
			baseType = parseTypeName(ref i);
		else if acceptrExtension(ref i, ContextualType.primitive):
			baseType = ClassDeclaration.primitive;

		expectr(ref i, TokenType.curlyOpen);

		var typeIniter;
		if acceptrExtension(ref i, ContextualType.initType)
		{
			expectr(ref i, TokenType.parenOpen);
			typeIniter = expectr(ref i, TokenType.string);
			expectr(ref i, TokenType.parenClose);
			expectr(ref i, TokenType.semicolon);
		}

		var members = parseClassMembers(ref i);

		var end = expectr(ref i, TokenType.curlyClose);
		return new ClassDeclaration(
			getLocation(start, end),
			modifiers,
			name,
			baseType,
			members,
			typeIniter
		);
	}

	private parseClassMembers(ref i)
	{
		/* Syntax:
		 *   class-member-declarations:
		 *     class-member-declaration
		 *     class-member-declarations class-member-declaration
		 *   class-member-declaration:
		 *     constructor-declaration
		 *     field-declaration
		 *     method-declaration
		 *     property-accessor-declaration
		 *     indexer-declaration
		 *     operator-declaration
		 *     iterator-declaration
		 *     static-constructor-declaration
		 *     class-constant-declaration
		 */
		var members = new List(5);

		var modifiers = new Modifiers();
		while not accept(i, TokenType.curlyClose)
		{
			parseModifiers(ref i, modifiers);

			var token = lex[i];
			var member;
			if token.match(TokenType.\new)
			{
				member = parseConstructorDeclaration(ref i, modifiers);
			}
			else if (token.contextualType == ContextualType.get or token.contextualType == ContextualType.set) and
				accept(i + 1, TokenType.identifier, TokenType.\this)
			{
				member = parsePropertyOrIndexerDeclaration(ref i, modifiers);
			}
			else if token.match(TokenType.\var)
			{
				member = parseFieldDeclaration(ref i, modifiers);
			}
			// Modifiers + 'this' = invocator without 'function' keyword; an indexer
			// always requires 'get' or 'set', which we check for above
			else if token.match(TokenType.\function, TokenType.\this)
			{
				member = parseMethodDeclaration(ref i, modifiers);
			}
			else if token.match(TokenType.\const)
			{
				member = parseClassConstantDeclaration(ref i, modifiers);
			}
			else if token.match(TokenType.\iter)
			{
				member = parseIteratorDeclaration(ref i, modifiers);
			}
			else if token.match(TokenType.\operator)
			{
				member = parseOperatorDeclaration(ref i, modifiers);
			}
			else
			{
				// Method declaration without 'function',
				// or field declaration without 'var'.
				// In both cases, we need an identifier.
				expect(i, TokenType.identifier);
				if accept(i + 1, TokenType.parenOpen):
					member = parseMethodDeclaration(ref i, modifiers);
				else:
					member = parseFieldDeclaration(ref i, modifiers);
			}

			members.add(member);
		}
		members = new NodeList(members);

		return members;
	}

	/// Summary: Parses a constructor declaration at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Param modifiers: (optional) An instance of {Modifiers}, which contains the member
	///          modifiers of the constructor declaration, such as an accessibility modifier
	///          or annotations. If null, this method will parse modifiers at {i} by calling
	///          {parseModifiers}.
	/// Returns: A {ConstructorDeclaration} or {StaticConstructorDeclaration} from the
	///          tokens at the starting index.
	/// Remarks: This method parses the grammar of both the 'constructor-declaration' and
	///          the 'static-constructor-declaration' nonterminals.
	public parseConstructorDeclaration(ref i, modifiers = null)
	{
		/* Syntax:
		 *   constructor-declaration:
		 *     accessibility-modifier? 'new' '(' ctor-parameter-list? ')' constructor-body
		 *   constructor-body:
		 *     block
		 *     ';'
		 *   static-constructor-declaration:
		 *     annotations? 'static' 'new' '(' ')' block
		 */
		if modifiers is null:
			modifiers = parseModifiers(ref i);
		modifiers.verifyForConstructor(this);

		var start = expectr(ref i, TokenType.\new);
		start = modifiers.start ?? start;

		expectr(ref i, TokenType.parenOpen);

		var parameters;
		if not modifiers.\static:
			parameters = parseConstructorParameterList(ref i);

		expectr(ref i, TokenType.parenClose);

		var body;
		if modifiers.\static or not acceptr(ref i, TokenType.semicolon):
			body = parseBlockOrExtern(ref i);

		var end = lex[i - 1];

		if modifiers.\static:
			return new StaticConstructorDeclaration(
				getLocation(start, end),
				modifiers.annotations,
				body
			);
		return new ConstructorDeclaration(
			getLocation(start, end),
			modifiers.annotations,
			modifiers.accessibility,
			parameters,
			body
		);
	}

	/// Summary: Parses a property or indexer declaration at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Param modifiers: (optional) An instance of {Modifiers}, which contains the member
	///          modifiers of the property declaration, such as an accessibility modifier
	///          or annotations. If null, this method will parse modifiers at {i} by calling
	///          {parseModifiers}.
	/// Returns: A {PropertyDeclaration} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of both the 'property-accessor-declaration'
	///          and the 'indexer-declaration' nonterminals.
	public parsePropertyOrIndexerDeclaration(ref i, modifiers = null)
	{
		/* Syntax:
		 *   property-accessor-declaration:
		 *     property-getter-declaration
		 *     property-setter-declaration
		 *   property-getter-declaration:
		 *     annotations? property-modifiers? 'get' identifier property-getter-body
		 *   property-setter-declaration:
		 *     annotations? property-modifiers? 'set' identifier property-setter-body
		 *   property-modifiers:
		 *     property-modifier
		 *     property-modifiers property-modifier
		 *   property-modifier:
		 *     accessibility-modifier
		 *     'static'
		 *     'abstract'
		 *     'overridable'
		 *     'override'
		 *   property-getter-body:
		 *     '=>' expression ';'
		 *     block
		 *     ';'
		 *   property-setter-body:
		 *     block
		 *     ';'
		 *   indexer-declaration:
		 *     indexer-getter-declaration
		 *     indexer-setter-declaration
		 *   indexer-getter-declaration:
		 *     annotations? property-modifiers? 'get' 'this' '[' parameter-list ']' property-getter-body
		 *   indexer-setter-declaration:
		 *     annotations? property-modifiers? 'set' 'this' '[' parameter-list ']' property-setter-body
		 * Additional notes:
		 *   This method parses both property-accessor-declaration and indexer-declaration,
		 *   since they both start with property-modifiers followed by 'get' or 'set'.
		 */
		if modifiers is null:
			modifiers = parseModifiers(ref i);

		var start = expectr(ref i, TokenType.identifier);

		var isSetter = false;
		if start.contextualType == ContextualType.set:
			isSetter = true;
		else if start.contextualType != ContextualType.get:
			fatalError(start, ErrorCode.err_UnexpectedToken);

		// name is null for indexer; indexerParams is null for property
		var name, indexerParams;
		if acceptr(ref i, TokenType.\this)
		{
			modifiers.verifyForIndexer(this);
			expectr(ref i, TokenType.squareOpen);

			indexerParams = parseParameterList(
				ref i,
				/*endToken=*/ TokenType.squareClose,
				/*allowEmpty=*/ false
			);
			if indexerParams.hasOptionalParameters:
				recoverableError(indexerParams.first(@.isOptional), ErrorCode.err_IndexerCannotHaveOptionalParameters);
			if indexerParams.hasVariadicParameter:
				recoverableError(indexerParams.first(@.isVariadic), ErrorCode.err_IndexerCannotHaveVariadicParameter);
			if indexerParams.hasRefParameters:
				recoverableError(indexerParams.first(@.isRef), ErrorCode.err_IndexerCannotHaveRefParameters);

			expectr(ref i, TokenType.squareClose);
		}
		else
		{
			modifiers.verifyForProperty(this);
			name = expectr(ref i, TokenType.identifier);
		}

		var body;
		if acceptr(ref i, TokenType.semicolon)
		{
			if not modifiers.\abstract:
				recoverableError(lex[i - 1], ErrorCode.err_NonAbstractPropertyCannotHaveEmptyBody);
			// otherwise, leave body null
		}
		else
		{
			if modifiers.\abstract:
				recoverableError(lex[i], ErrorCode.err_AbstractPropertyMustHaveEmptyBody);

			if not isSetter and acceptr(ref i, TokenType.fatArrow)
			{
				body = parseExpression(ref i);
				expectr(ref i, TokenType.semicolon);
			}
			else
			{
				body = parseBlockOrExtern(ref i);
			}
		}

		var location = getLocation(modifiers.start ?? start, lex[i - 1]);
		if name is null:
			return new IndexerDeclaration(location, modifiers, isSetter, indexerParams, body);
		return new PropertyDeclaration(location, modifiers, isSetter, name, body);
	}

	/// Summary: Parses a field declaration at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Param modifiers: (optional) An instance of {Modifiers}, which contains the member
	///          modifiers of the field declaration, such as an accessibility modifier or
	///          annotations. If null, this method will parse modifiers at {i} by calling
	///          {parseModifiers}.
	/// Returns: A {FieldDeclaration} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'field-declaration' nonterminal.
	public parseFieldDeclaration(ref i, modifiers = null)
	{
		/* Syntax:
		 *   field-declaration:
		 *     annotations? field-modifiers 'var'? field-declarators ';'
		 *     annotations? field-modifiers? 'var' field-declarators ';'
		 *   field-modifiers:
		 *     field-modifier
		 *     field-modifiers field-modifier
		 *   field-modifier:
		 *     accessibility-modifier
		 *     'static'
		 *   field-declarators:
		 *     field-declarator
		 *     field-declarators ',' field-declarator
		 *   field-declarator:
		 *     identifier
		 *     identifier '=' expression
		 */
		if modifiers is null:
			modifiers = parseModifiers(ref i);
		modifiers.verifyForField(this);

		var start = lex[i];

		acceptr(ref i, TokenType.\var);

		var fields = new List(1);
		do
		{
			var name = expectr(ref i, TokenType.identifier);
			var value;
			if acceptr(ref i, TokenType.assign):
				value = parseExpression(ref i);

			fields.add(
				new VariableDeclarator(
					getLocation(name, value ?? name),
					name, value
				)
			);
		} while acceptr(ref i, TokenType.comma);
		fields = new NodeList(fields);

		var end = expectr(ref i, TokenType.semicolon);

		return new FieldDeclaration(
			getLocation(modifiers.start ?? start, end),
			modifiers,
			fields
		);
	}

	/// Summary: Parses a method or invocator declaration at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Param modifiers: (optional) An instance of {Modifiers}, which contains the member
	///          modifiers of the method declaration, such as an accessibility modifier
	///          or annotations. If null, this method will parse modifiers at {i} by calling
	///          {parseModifiers}.
	/// Returns: A {MethodDeclaration} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'method-declaration' nonterminal.
	public parseMethodDeclaration(ref i, modifiers = null)
	{
		/* Syntax:
		 *   method-declaration:
		 *     annotations? method-modifiers? 'function'? method-name '(' parameter-list? ')' method-body
		 *   method-modifiers:
		 *     method-modifier
		 *     method-modifiers method-modifier
		 *   method-modifier:
		 *     accessibility-modifier
		 *     'static'
		 *     'abstract'
		 *     'overridable'
		 *     'override'
		 *   method-name:
		 *     identifier
		 *     'this'
		 *   method-body:
		 *     block
		 *     ';'
		 * Additional notes:
		 *   When extensions are enabled, a method-body can also be an `__extern` body.
		 */
		if modifiers is null:
			modifiers = parseModifiers(ref i);

		var start = lex[i];

		acceptr(ref i, TokenType.\function);

		var name; // leave null for invocator
		if acceptr(ref i, TokenType.\this)
		{
			modifiers.verifyForInvocator(this);
		}
		else
		{
			modifiers.verifyForMethod(this);
			name = expectr(ref i, TokenType.identifier);
		}

		expectr(ref i, TokenType.parenOpen);
		var parameters = parseParameterList(ref i);
		expectr(ref i, TokenType.parenClose);

		var body;
		if acceptr(ref i, TokenType.semicolon)
		{
			if not modifiers.\abstract:
				recoverableError(lex[i - 1], ErrorCode.err_NonAbstractMethodCannotHaveEmptyBody);
			// Otherwise, leave body null
		}
		else
		{
			if modifiers.\abstract:
				recoverableError(lex[i], ErrorCode.err_AbstractMethodMustHaveEmptyBody);
			body = parseBlockOrExtern(ref i);
		}

		var location = getLocation(modifiers.start ?? start, lex[i - 1]);
		if name is null:
			return new InvocatorDeclaration(location, modifiers, parameters, body);
		return new MethodDeclaration(location, modifiers, name, parameters, body);
	}

	/// Summary: Parses a class constant declaration at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Param modifiers: (optional) An instance of {Modifiers}, which contains the member
	///          modifiers of the constant declaration, such as an accessibility modifier
	///          or annotations. If null, this method will parse modifiers at {i} by calling
	///          {parseModifiers}.
	/// Returns: A {ClassConstantDeclaration} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'class-constant-declaration' nonterminal.
	public parseClassConstantDeclaration(ref i, modifiers = null)
	{
		/* Syntax:
		 *   class-constant-declaration:
		 *     annotations? accessibility-modifier? 'const' constant-declarators ';'
		 *   constant-declarators:
		 *     constant-declarator
		 *     constant-declarators ',' constant-declarator
		 *   constant-declarator:
		 *     identifier '=' constant-expression
		 * Additional notes:
		 *   This is not the only method that parses constant-declarators, due to their
		 *   underwhelming simplicity.
		 */
		if modifiers is null:
			modifiers = parseModifiers(ref i);
		modifiers.verifyForClassConstant(this);

		var start = expectr(ref i, TokenType.\const);

		var constants = new List(1);
		do
		{
			var name = expectr(ref i, TokenType.identifier);
			expectr(ref i, TokenType.assign, ErrorCode.err_ConstantWithoutValue);
			var value = parseExpression(ref i);

			constants.add(
				new VariableDeclarator(
					getLocation(name, value),
					name, value
				)
			);
		} while acceptr(ref i, TokenType.comma);
		constants = new NodeList(constants);

		var end = expectr(ref i, TokenType.semicolon);

		return new ClassConstantDeclaration(
			getLocation(modifiers.start ?? start, end),
			modifiers.annotations, modifiers.accessibility, constants
		);
	}

	/// Summary: Parses an iterator declaration at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Param modifiers: (optional) An instance of {Modifiers}, which contains the member
	///          modifiers of the iterator declaration, such as an accessibility modifier
	///          or annotations. If null, this method will parse modifiers at {i} by calling
	///          {parseModifiers}.
	/// Returns: An {IteratorDeclaration} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'iterator-declaration' nonterminal.
	public parseIteratorDeclaration(ref i, modifiers = null)
	{
		/* Syntax:
		 *   iterator-declaration:
		 *     annotations? 'iter' block
		 * Additional notes:
		 *   When extensions are enabled, the body can also be an `__extern` block.
		 */
		if modifiers is null:
			modifiers = parseModifiers(ref i);
		modifiers.verifyForIterator(this);

		var start = expectr(ref i, TokenType.\iter);

		var body = parseBlockOrExtern(ref i);

		return new IteratorDeclaration(
			getLocation(start, body),
			modifiers.annotations, body
		);
	}

	/// Summary: Parses an operator declaration at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Param modifiers: (optional) An instance of {Modifiers}, which contains the member
	///          modifiers of the operator declaration, such as an accessibility modifier
	///          or annotations. If null, this method will parse modifiers at {i} by calling
	///          {parseModifiers}.
	/// Returns: An {OperatorDeclaration} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'operator-declaration' nonterminal.
	public parseOperatorDeclaration(ref i, modifiers = null)
	{
		/* Syntax:
		 *   operator-declaration:
		 *     annotations? 'operator' unary-operator-declarator block
		 *     annotations? 'operator' binary-operator-declarator block
		 *   unary-operator-declarator:
		 *     overloadable-unary-operator '(' identifier ')'
		 *   overloadable-unary-operator: one of
		 *     '+'  '-'  '~'
		 *   binary-operator-declarator:
		 *     overloadable-binary-operator '(' identifier ',' identifier ')'
		 *   overloadable-binary-operator: one of
		 *     '+'  '-'  '|'   '^'   '*'   '/'    '%'  '&'  '**'
		 *     '<<'  '>>'  '=='  '<=>'
		 * Additional notes:
		 *   When extensions are enabled, the body can also be an `__extern` body.
		 *
		 *   We use parseParameterList to parse the parameters to the operator overload,
		 *   which allows us to give better error messages if there are variadic, optional
		 *   or ref parameters in the list.
		 *
		 *   The overloadable-binary-operator symbol is represented by the category
		 *   TokenType.overloadableBinaryOperator. Note that this category contains
		 *   '+' and '-' as well, both of which are also unary operators.
		 */
		if modifiers is null:
			modifiers = parseModifiers(ref i);
		modifiers.verifyForOperator(this);

		var start = expectr(ref i, TokenType.\operator);

		var opToken, op;
		if accept(i, TokenType.tilde)
		{
			opToken = lex[i];
			i += 1;
			op = UnaryOperator.bitwiseNot;
		}
		else
		{
			opToken = expectr(ref i, TokenType.overloadableBinaryOperator);
			op = typeToBinaryOperator[opToken.type];
		}

		expectr(ref i, TokenType.parenOpen);
		var parameters = parseParameterList(
			ref i,
			/*endToken=*/ TokenType.parenClose,
			/*allowEmpty=*/ false
		);
		expectr(ref i, TokenType.parenClose);

		if parameters.hasOptionalParameters:
			recoverableError(parameters.first(@.isOptional), ErrorCode.err_OperatorCannotHaveOptionalParameters);
		if parameters.hasVariadicParameter:
			recoverableError(parameters.first(@.isVariadic), ErrorCode.err_OperatorCannotHaveVariadicParameter);
		if parameters.hasRefParameters:
			recoverableError(parameters.first(@.isRef), ErrorCode.err_OperatorCannotHaveRefParameters);

		// If op is UnaryOperator.bitwiseNot, we always expect exactly one parameter.
		// If it's BinaryOperator.addition or BinaryOperator.subtraction, we expect one or two
		// (and update to UnaryOperator.plus/negation if we find one parameter).
		// Otherwise, we always expect exactly two.
		if op == UnaryOperator.bitwiseNot
		{
			if parameters.length != 1:
				recoverableError(
					opToken, ErrorCode.err_WrongParameterCountForUnaryOperator,
					[parameters.length]
				);
		}
		else if op == BinaryOperator.addition or op == BinaryOperator.subtraction
		{
			if parameters.length == 1:
				op = op == BinaryOperator.addition ?
					UnaryOperator.plus :
					UnaryOperator.negation;
			else if parameters.length != 2:
				recoverableError(
					opToken, ErrorCode.err_WrongParameterCountForUnaryOrBinaryOperator,
					[parameters.length]
				);
		}
		else
		{
			if parameters.length != 2:
				recoverableError(
					opToken, ErrorCode.err_WrongParameterCountForBinaryOperator,
					[parameters.length]
				);
		}

		var body = parseBlockOrExtern(ref i);

		return new OperatorDeclaration(
			getLocation(start, body),
			modifiers.annotations, op, parameters, body
		);
	}

	/// Summary: Parses an enum declaration at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Param modifiers: (optional) An instance of {Modifiers}, which contains the member
	///          modifiers of the enum declaration, such as an accessibility modifier or
	///          annotations. If null, this method will parse modifiers at {i} by calling
	///          {parseModifiers}.
	/// Returns: An {EnumDeclaration} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'enum-declaration' nonterminal.
	public parseEnumDeclaration(ref i, modifiers = null)
	{
		/* Syntax:
		 *   enum-declaration:
		 *     simple-enum-declaration
		 *     enum-set-declaration
		 *   simple-enum-declaration:
		 *     annotations? enum-modifier? 'enum' identifier '{' simple-enum-body? '}'
		 *   enum-modifier:
		 *     'public'
		 *     'internal'
		 *   simple-enum-body:
		 *     enum-members ','?
		 *   enum-members:
		 *     enum-member
		 *     enum-members ',' enum-member
		 *   enum-member:
		 *     annotations? identifier
		 *     annotations? identifier '=' constant-expression
		 *   enum-set-declaration:
		 *     annotations? enum-modifier? 'enum' 'set' identifier '{' enum-set-body? '}'
		 *   enum-set-body:
		 *     enum-members ','?
		 */
		if modifiers is null:
			modifiers = parseModifiers(ref i);
		modifiers.verifyForEnum(this);

		var start = expectr(ref i, TokenType.\enum);
		var isSet = false;
		if acceptContextual(i, ContextualType.set) and
			accept(i + 1, TokenType.identifier)
		{
			i += 1; // Skip 'set'
			isSet = true;
		}

		var typeName = expectr(ref i, TokenType.identifier);

		expectr(ref i, TokenType.curlyOpen);

		var members = new List(5);
		if not accept(i, TokenType.curlyClose):
			do
			{
				var fieldAnnotations = parseAnnotations(ref i);

				var fieldName = expectr(ref i, TokenType.identifier);
				var value;
				if acceptr(ref i, TokenType.assign):
					value = parseExpression(ref i);

				members.add(
					new EnumMember(
						getLocation(fieldName, value ?? fieldName),
						fieldAnnotations, fieldName, value
					)
				);
			} while acceptr(ref i, TokenType.comma) and
				not accept(i, TokenType.curlyClose);
		members = new NodeList(members);

		var end = expectr(ref i, TokenType.curlyClose);
		return new EnumDeclaration(
			getLocation(modifiers.start ?? start, end),
			modifiers.annotations,
			modifiers.accessibility,
			isSet,
			typeName,
			members
		);
	}

	//</region>

	//<region: Statements>

	/// Summary: Parses a block or `__extern` body at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: A {Block} or {ExternBody} from the tokens at the starting index.
	/// Remarks: `__extern` bodies are a compiler extension, and will not be parsed unless
	///          extensions are enabled. This method is intended to be used by constructs
	///          that take a block or `__extern` as its body, e.g. a method or iterator.
	///          Do not use it for blocks in general.
	public parseBlockOrExtern(ref i)
	{
		/* Syntax:
		 *   block-or-extern:   (non-standard extension, replaces some function member bodies)
		 *     block
		 *     extern-body
		 */
		if acceptExtension(i, ContextualType.extern):
			return parseExternBody(ref i);
		return parseBlock(ref i);
	}

	/// Summary: Parses an `__extern` body at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: An {ExternBody} from the tokens at the starting index.
	public parseExternBody(ref i)
	{
		/* Syntax:
		 *   extern-body:   (non-standard extension)
		 *     '__extern' '(' string-literal ')' ';'
		 *     '__extern' '(' string-literal ',' extern-parameters ')' ';'
		 *   extern-parameters:
		 *     extern-parameter
		 *     extern-parameters ',' extern-parameter
		 *   extern-parameter:
		 *     identifier '=' constant-expression
		 * Additional notes:
		 *   The only extern-parameter so far is "locals".
		 */
		var start = lex[i];
		if not acceptExtension(i, ContextualType.extern):
			fatalError(start, ErrorCode.err_x_ExpectedExternKeyword);
		i += 1;

		expectr(ref i, TokenType.parenOpen);
		var externName = expectr(ref i, TokenType.string, ErrorCode.err_x_ExpectedExternMethodName);

		var locals;
		while acceptr(ref i, TokenType.comma)
		{
			var param = expectr(ref i, TokenType.identifier);
			expectr(ref i, TokenType.assign);
			var value = parseExpression(ref i);

			var paramName = param.identifier;
			if paramName == "locals":
				locals = value;
			else:
				fatalError(param, ErrorCode.err_x_UnknownExternParameter, [paramName]);
		}

		expectr(ref i, TokenType.parenClose);
		var end = expectr(ref i, TokenType.semicolon);

		return new ExternBody(
			getLocation(start, end),
			externName, locals
		);
	}

	/// Summary: Parses a block at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: A {Block} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'block' nonterminal.
	public parseBlock(ref i)
	{
		/* Syntax:
		 *   block:
		 *     '{' statement-list? '}'
		 *   statement-list:
		 *     statement
		 *     statement-list statement
		 */
		var start = expectr(ref i, TokenType.curlyOpen);

		var statements = new List(4);
		while not accept(i, TokenType.curlyClose):
			statements.add(parseStatement(ref i));
		statements = new NodeList(statements);

		var end = expectr(ref i, TokenType.curlyClose);

		return new Block(getLocation(start, end), statements);
	}

	/// Summary: Parses a statement at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: A {Statement} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'statement' nonterminal.
	public parseStatement(ref i)
	{
		/* Syntax:
		 *   statement:
		 *     declaration-statement
		 *     embedded-statement
		 *   declaration-statement:
		 *     local-variable-declaration
		 *     local-constant-declaration
		 *     local-function-declaration
		 */
		var token = lex[i];
		if token.match(TokenType.\var):
			return parseLocalVariableDeclaration(ref i);
		if token.match(TokenType.\const):
			return parseLocalConstantDeclaration(ref i);
		if token.match(TokenType.\function):
			return parseLocalFunctionDeclaration(ref i);
		return parseEmbeddedStatement(ref i);
	}

	/// Summary: Parses a local variable declaration at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: A {LocalDeclaration} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'local-variable-declaration' nonterminal.
	public parseLocalVariableDeclaration(ref i)
	{
		/* Syntax:
		 *   local-variable-declaration:
		 *     'var' local-variable-declarators ';'
		 *   local-variable-declarators:
		 *     local-variable-declarator
		 *     local-variable-declarators ',' local-variable-declarator
		 *   local-variable-declarator:
		 *     identifier
		 *     identifier '=' expression
		 *   identifier-list:
		 *     identifier
		 *     identifier-list ',' identifier
		 */
		var start = expectr(ref i, TokenType.\var);

		var variables = new List(1);
		do
		{
			var name = expectr(ref i, TokenType.identifier);
			var value;
			if acceptr(ref i, TokenType.assign):
				value = parseExpression(ref i);

			var location = value ?
				getLocation(name, value) :
				name.location;
			variables.add(
				new VariableDeclarator(location, name, value)
			);
		} while acceptr(ref i, TokenType.comma);
		variables = new NodeList(variables);

		var end = expectr(ref i, TokenType.semicolon, ErrorCode.err_ExpectedStatementTerminator);

		return new LocalVariableDeclaration(
			getLocation(start, end),
			variables
		);
	}

	/// Summary: Parses a local constant declaration at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: A {LocalConstantDeclaration} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'local-constant-declaration' nonterminal.
	public parseLocalConstantDeclaration(ref i)
	{
		/* Syntax:
		 * local-constant-declaration:
		 *   'const' constant-declarators ';'
		 * constant-declarators:
		 *   constant-declarator
		 *   constant-declarators ',' constant-declarator
		 * constant-declarator:
		 *   identifier '=' constant-expression
		 * Additional notes:
		 *   This is not the only method that parses constant-declarators, due to their
		 *   underwhelming simplicity.
		 */
		var start = expectr(ref i, TokenType.\const);

		var constants = new List(1);
		do
		{
			var name = expectr(ref i, TokenType.identifier);
			expectr(ref i, TokenType.assign, ErrorCode.err_ConstantWithoutValue);
			var value = parseExpression(ref i);

			constants.add(
				new VariableDeclarator(getLocation(name, value), name, value)
			);
		} while acceptr(ref i, TokenType.comma);
		constants = new NodeList(constants);

		var end = expectr(ref i, TokenType.semicolon, ErrorCode.err_ExpectedStatementTerminator);

		return new LocalConstantDeclaration(
			getLocation(start, end),
			constants
		);
	}

	/// Summary: Parses a local function declaration at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: A {LocalFunctionDeclaration} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'local-function-declaration' nonterminal.
	public parseLocalFunctionDeclaration(ref i)
	{
		/* Syntax:
		 *   local-function-declaration:
		 *     'function' identifier '(' parameter-list? ')' block
		 * Additional notes:
		 *   Local functions never accept `__extern` bodies.
		 */
		var start = expectr(ref i, TokenType.\function);

		var name = expectr(ref i, TokenType.identifier);

		expectr(ref i, TokenType.parenOpen);
		var parameters = parseParameterList(ref i);
		expectr(ref i, TokenType.parenClose);

		var body = parseBlock(ref i);

		return new LocalFunctionDeclaration(
			getLocation(start, body),
			name, parameters, body
		);
	}

	/// Summary: Parses an embedded statement at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: A {Statement} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'embedded-statement' nonterminal.
	public parseEmbeddedStatement(ref i)
	{
		/* Syntax:
		 *   embedded-statement:
		 *     empty-statement
		 *     expression-statement
		 *     if-statement
		 *     iteration-statement
		 *     jump-statement
		 *     try-statement
		 *     with-statement
		 *     assignment-statement
		 *     constructor-call
		 *   iteration-statement:
		 *     loop-label? for-statement
		 *     loop-label? while-statement
		 *     loop-label? do-while-statement
		 *   loop-label:
		 *     identifier ':'
		 * Additional notes:
		 *    Assignment statements are processed by parseExpressionStatement, since
		 *    all assignment statements begin with an expression.
		 */

		// Try to see if we have a loop label first
		var loopLabel;
		if accept(i, TokenType.identifier) and accept(i + 1, TokenType.colon)
		{
			loopLabel = lex[i];
			i += 2; // skip label and ':'
		}
		var token = lex[i];
		if token.match(TokenType.\for):
			return parseForStatement(ref i, loopLabel);
		if token.match(TokenType.\while):
			return parseWhileStatement(ref i, loopLabel);
		if token.match(TokenType.\do):
			return parseDoWhileStatement(ref i, loopLabel);
		// If there is a label and we didn't find an iteration statement, that's a paddlin'.
		// I mean, that's an error.
		if loopLabel:
			fatalError(loopLabel, ErrorCode.err_ExpectedLoopAfterLabel);

		// Other statement kinds!
		if token.match(TokenType.\if):
			return parseIfStatement(ref i);
		if jumpStatementTypes.contains(token.type):
			return parseJumpStatement(ref i);
		if token.match(TokenType.\try):
			return parseTryStatement(ref i);
		if token.match(TokenType.\with):
			return parseWithStatement(ref i);
		if token.match(TokenType.\new) and accept(i + 1, TokenType.\this, TokenType.\base):
			return parseConstructorCall(ref i);
		if token.match(TokenType.semicolon)
		{
			i += 1;
			return new EmptyStatement(getLocation(token, token));
		}

		return parseExpressionStatement(ref i);
	}

	/// Summary: Parses a `for` statement at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Param loopLabel: (optional) If specified, contains the loop label attached to the
	///          iteration statement. This method does not otherwise parse loop labels.
	/// Returns: A {ForStatement} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'for-statement' nonterminal.
	public parseForStatement(ref i, loopLabel = null)
	{
		/* Syntax:
		 *   for-statement:
		 *     'for' identifier-list 'in' expression control-statement else-clause?
		 */
		var start = expectr(ref i, TokenType.\for);

		var variables = new List(1);
		do
		{
			variables.add(expectr(ref i, TokenType.identifier));
		} while acceptr(ref i, TokenType.comma);
		variables = new SyntaxList(variables);

		expectr(ref i, TokenType.\in);

		var expression = parseExpression(ref i);

		var body = parseControlStatement(ref i);

		var elseClause;
		if accept(i, TokenType.\else):
			elseClause = parseElseClause(ref i);

		return new ForStatement(
			getLocation(start, elseClause ?? body),
			loopLabel,
			variables,
			expression,
			body,
			elseClause
		);
	}

	/// Summary: Parses a `while` statement at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Param loopLabel: (optional) If specified, contains the loop label attached to the
	///          iteration statement. This method does not otherwise parse loop labels.
	/// Returns: A {WhileStatement} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'while-statement' nonterminal.
	public parseWhileStatement(ref i, loopLabel = null)
	{
		/* Syntax:
		 *   while-statement:
		 *     'while' expression control-statement
		 */
		var start = expectr(ref i, TokenType.\while);

		var condition = parseExpression(ref i);

		var body = parseControlStatement(ref i);

		return new WhileStatement(
			getLocation(start, body),
			loopLabel, condition, body
		);
	}

	/// Summary: Parses a `do-while` statement at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Param loopLabel: (optional) If specified, contains the loop label attached to the
	///          iteration statement. This method does not otherwise parse loop labels.
	/// Returns: A {DoWhileStatement} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'do-while-statement' nonterminal.
	public parseDoWhileStatement(ref i, loopLabel = null)
	{
		/* Syntax:
		 *   do-while-statement:
		 *     'do' block 'while' expression ';'
		 *     'do' block ';'
		 */
		var start = expectr(ref i, TokenType.\do);

		var body = parseBlock(ref i);

		var condition;
		if acceptr(ref i, TokenType.\while):
			condition = parseExpression(ref i);

		var end = expectr(ref i, TokenType.semicolon, ErrorCode.err_ExpectedStatementTerminator);

		return new DoWhileStatement(
			getLocation(start, end),
			loopLabel, body, condition
		);
	}

	/// Summary: Parses an `if` statement at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: An {IfStatement} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'if-statement' nonterminal.
	public parseIfStatement(ref i)
	{
		/* Syntax:
		 *   if-statement:
		 *     'if' expression control-statement else-clause?
		 */
		var start = expectr(ref i, TokenType.\if);

		var condition = parseExpression(ref i);
		var consequence = parseControlStatement(ref i);
		var alternative;
		if accept(i, TokenType.\else):
			alternative = parseElseClause(ref i);

		return new IfStatement(
			getLocation(start, alternative ?? consequence),
			condition, consequence, alternative
		);
	}

	/// Summary: Parses an `else` clause at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: A {Statement} that represents the body of the else clause.
	/// Remarks: This method parses the grammar of the 'else-clause' nonterminal.
	public parseElseClause(ref i)
	{
		/* Syntax:
		 *   else-clause:
		 *     'else' ':'? embedded-statement
		 *     'else' block
		 */
		expectr(ref i, TokenType.\else);

		if accept(i, TokenType.curlyOpen):
			return parseBlock(ref i);

		acceptr(ref i, TokenType.colon);
		return parseEmbeddedStatement(ref i);
	}

	/// Summary: Parses a jump statement (`return`, `yield`, `next`, `break` or `throw`)
	///          at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: A {Statement} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'jump-statement' nonterminal.
	public parseJumpStatement(ref i)
	{
		/* Syntax:
		 *   jump-statement:
		 *     return-statement
		 *     yield-statement
		 *     next-statement
		 *     break-statement
		 *     throw-statement
		 */
		var token = lex[i];
		if token.match(TokenType.\return):
			return parseReturnStatement(ref i);
		if token.match(TokenType.\yield):
			return parseYieldStatement(ref i);
		if token.match(TokenType.\next):
			return parseNextStatement(ref i);
		if token.match(TokenType.\break):
			return parseBreakStatement(ref i);
		if token.match(TokenType.\throw):
			return parseThrowStatement(ref i);
		fatalError(token, ErrorCode.err_ExpectedJumpStatement);
	}

	/// Summary: Parses a `return` statement at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: A {ReturnStatement} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'return-statement' nonterminal.
	public parseReturnStatement(ref i)
	{
		/* Syntax:
		 *   return-statement:
		 *     'return' expression? ';'
		 */
		var start = expectr(ref i, TokenType.\return);

		var value = null;
		if not accept(i, TokenType.semicolon)
		{
			value = parseExpression(ref i);
		}

		var end = expectr(ref i, TokenType.semicolon, ErrorCode.err_ExpectedStatementTerminator);

		return new ReturnStatement(getLocation(start, end), value);
	}

	/// Summary: Parses a `yield` statement at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: A {YieldStatement} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'yield-statement' nonterminal.
	public parseYieldStatement(ref i)
	{
		/* Syntax:
		 *   yield-statement:
		 *     'yield' expression ';'
		 */
		var start = expectr(ref i, TokenType.\yield);

		var value = parseExpression(ref i);

		var end = expectr(ref i, TokenType.semicolon, ErrorCode.err_ExpectedStatementTerminator);

		return new YieldStatement(getLocation(start, end), value);
	}

	/// Summary: Parses a `next` statement at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: A {NextStatement} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'next-statement' nonterminal.
	public parseNextStatement(ref i)
	{
		/* Syntax:
		 *   next-statement:
		 *     'next' identifier? ';'
		 */
		var start = expectr(ref i, TokenType.\next);

		var label;
		if accept(i, TokenType.identifier)
		{
			label = lex[i];
			i += 1;
		}

		var end = expectr(ref i, TokenType.semicolon, ErrorCode.err_ExpectedStatementTerminator);

		return new NextStatement(getLocation(start, end), label);
	}

	/// Summary: Parses a `break` statement at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: A {BreakStatement} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'break-statement' nonterminal.
	public parseBreakStatement(ref i)
	{
		/* Syntax:
		 *   break-statement:
		 *     'break' identifier? ';'
		 */
		var start = expectr(ref i, TokenType.\break);

		var label;
		if accept(i, TokenType.identifier)
		{
			label = lex[i];
			i += 1;
		}

		var end = expectr(ref i, TokenType.semicolon, ErrorCode.err_ExpectedStatementTerminator);

		return new BreakStatement(getLocation(start, end), label);
	}

	/// Summary: Parses a `throw` statement at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: A {ThrowStatement} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'throw-statement' nonterminal.
	public parseThrowStatement(ref i)
	{
		/* Syntax:
		 *   throw-statement:
		 *     'throw' expression? ';'
		 */
		var start = expectr(ref i, TokenType.\throw);

		var expr;
		if not accept(i, TokenType.semicolon):
			expr = parseExpression(ref i);

		var end = expectr(ref i, TokenType.semicolon, ErrorCode.err_ExpectedStatementTerminator);

		return new ThrowStatement(getLocation(start, end), expr);
	}

	/// Summary: Parses a `try` statement at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: A {TryStatement} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'try-statement' nonterminal.
	public parseTryStatement(ref i)
	{
		/* Syntax:
		 *   try-statement:
		 *     try-clause catch-clauses
		 *     try-clause finally-clause
		 *     try-clause catch-clauses finally-clause
		 */

		var tryClause = parseTryClause(ref i);
		var catchClauses = parseCatchClauses(ref i);
		var finallyClause = parseFinallyClause(ref i);

		if catchClauses.length == 0 and finallyClause is null:
			recoverableError(tryClause, ErrorCode.err_TryStatementMustHaveCatchOrFinally);

		return new TryStatement(
			getLocation(tryClause, lex[i - 1]),
			tryClause,
			catchClauses,
			finallyClause
		);
	}

	private parseTryClause(ref i)
	{
		/* Syntax:
		 *   try-clause:
		 *     'try' block
		 */
		var start = expectr(ref i, TokenType.\try);

		expectr(ref i, TokenType.curlyOpen);

		var statements = new List(2);
		while not accept(i, TokenType.curlyClose):
			statements.add(parseStatement(ref i));
		statements = new NodeList(statements);

		var end = expectr(ref i, TokenType.curlyClose);

		return new TryClause(getLocation(start, end), statements);
	}

	private parseCatchClauses(ref i)
	{
		/* Syntax:
		 *   catch-clauses:
		 *     specific-catch-clauses generic-catch-clause?
		 *     specific-catch-clauses? generic-catch-clause
		 *   specific-catch-clauses:
		 *     specific-catch-clause
		 *     specific-catch-clauses specific-catch-clause
		 *   specific-catch-clause:
		 *     'catch' type 'in' identifier block
		 *     'catch' type block
		 *   generic-catch-clause:
		 *     'catch' block
		 */
		if not accept(i, TokenType.\catch):
			return EmptyLists.node;

		var clauses = new List(1);
		var haveGeneric = false;
		while accept(i, TokenType.\catch)
		{
			var start = lex[i];
			i += 1;

			var type, variable;
			if not accept(i, TokenType.curlyOpen)
			{
				type = parseTypeName(ref i);
				if acceptr(ref i, TokenType.\in):
					variable = expectr(ref i, TokenType.identifier);
			}

			expectr(ref i, TokenType.curlyOpen);

			var statements = new List(1);
			while not accept(i, TokenType.curlyClose):
				statements.add(parseStatement(ref i));
			statements = new NodeList(statements);

			var end = expectr(ref i, TokenType.curlyClose);
			var catchClause;
			if type
			{
				if haveGeneric:
					recoverableError(type, ErrorCode.err_SpecificCatchClauseAfterGeneric);
				catchClause = new SpecificCatchClause(
					getLocation(start, end),
					type,
					variable,
					statements
				);
			}
			else
			{
				if haveGeneric:
					recoverableError(start, ErrorCode.err_MultipleGenericCatchClauses);
				haveGeneric = true;
				catchClause = new GenericCatchClause(
					getLocation(start, end),
					statements
				);
			}
			clauses.add(catchClause);
		}

		return new NodeList(clauses);
	}

	private parseFinallyClause(ref i)
	{
		/* Syntax:
		 *   finally-clause:
		 *     'finally' block
		 */
		if accept(i, TokenType.\finally)
		{
			var start = lex[i];
			i += 1;
			expectr(ref i, TokenType.curlyOpen);

			var statements = new List(1);
			while not accept(i, TokenType.curlyClose):
				statements.add(parseStatement(ref i));
			statements = new NodeList(statements);

			var end = expectr(ref i, TokenType.curlyClose);

			return new FinallyClause(getLocation(start, end), statements);
		}

		return null;
	}

	/// Summary: Parses a `with` statement at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: A {WithStatement} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'with-statement' nonterminal.
	public parseWithStatement(ref i)
	{
		/* Syntax:
		 *   with-statement:
		 *     'with' identifier '=' expression control-statement
		 */
		var start = expectr(ref i, TokenType.\with);

		var variable = expectr(ref i, TokenType.identifier);
		expectr(ref i, TokenType.assign, ErrorCode.err_WithStatementVariableWithoutValue);
		var expression = parseExpression(ref i);

		var body = parseControlStatement(ref i);

		return new WithStatement(
			getLocation(start, body),
			variable,
			expression,
			body
		);
	}

	/// Summary: Parses a control statement at the specified token index. A control
	///          statement is the body of another statement, and consists of either
	///          a block, or a colon followed by an embedded statement.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: A {Statement} that represents the control statement.
	/// Remarks: This method parses the grammar of the 'control-statement' nonterminal.
	public parseControlStatement(ref i)
	{
		/* Syntax:
		 *   control-statement:
		 *     ':' embedded-statement
		 *     block
		 */
		if acceptr(ref i, TokenType.colon):
			return parseEmbeddedStatement(ref i);
		return parseBlock(ref i);
	}

	/// Summary: Parses a constructor call at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: A {BaseConstructorCall} or {ThisConstructorCall} from the tokens at the
	///          starting index.
	/// Remarks: This method parses the grammar of the 'constructor-call' nonterminal.
	public parseConstructorCall(ref i)
	{
		/* Syntax:
		 *   constructor-call:
		 *     base-initializer
		 *     this-initializer
		 *   base-initializer:
		 *     'new' 'base' '(' argument-list? ')' ';'
		 *   this-initializer:
		 *     'new' 'this' '(' argument-list? ')' ';'
		 */
		var start = expectr(ref i, TokenType.\new);
		var isBase = acceptr(ref i, TokenType.\base);
		if not isBase:
			expectr(ref i, TokenType.\this);

		expectr(ref i, TokenType.parenOpen);
		var arguments = parseArgumentList(ref i);
		expectr(ref i, TokenType.parenClose);
		var end = expectr(ref i, TokenType.semicolon, ErrorCode.err_ExpectedStatementTerminator);

		if isBase:
			return new BaseConstructorCall(getLocation(start, end), arguments);
		return new ThisConstructorCall(getLocation(start, end), arguments);
	}

	/// Summary: Parses an expression statement or assignment statement at the specified
	///          token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: A {Statement} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of both the 'expression-statement' and
	///          the 'assignment-statement' nonterminals.
	public parseExpressionStatement(ref i)
	{
		/* Syntax:
		 *   expression-statement:
		 *     statement-expression ';'
		 *   statement-expression:
		 *     invocation-expression
		 *     function-application-expression
		 *     object-creation-expression
		 *     assignment-expression
		 *     A safe-access whose last safe-access-link (if it has a safe-access-chain)
		 *       or whose safe-start-component (if it does not) is a safe-invocation or
		 *       unsafe-invocation
		 *   assignment-statement:
		 *     simple-assignment-statement
		 *     compound-assignment-statement
		 *     parallel-assignment-statement
		 * Additional notes:
		 *   When a statement-expression is a function-application-expression, it must be
		 *   an expression that uses the '->' operator. In this compiler, that means the
		 *   node must be a BinaryExpression using BinaryOperator.functionApplication.
		 *
		 *   This method also parses assignment-statements, since they all start with an
		 *   expression. The compound-assignment-operator symbol is represented by the
		 *   TokenType.compoundAssign category.
		 */
		var expr = parseExpression(ref i);

		if accept(i, TokenType.assign):
			// simple-assignment-statement
			return parseSimpleAssignment(ref i, expr);
		if accept(i, TokenType.compoundAssign):
			// compound-assignment-statement
			return parseCompoundAssignment(ref i, expr);
		if accept(i, TokenType.comma):
			// parallel-assignment-statement
			return parseParallelAssignment(ref i, expr);

		var end = expectr(ref i, TokenType.semicolon, ErrorCode.err_ExpectedStatementTerminator);

		if not isStatementExpression(expr):
			recoverableError(expr, ErrorCode.err_InvalidStatementExpression);

		return new ExpressionStatement(getLocation(expr, end), expr);
	}

	private parseSimpleAssignment(ref i, target)
	{
		/* Syntax:
		 *   simple-assignment-statement:
		 *     primary-expression '=' expression ';'
		 */
		ensureAssignable(target);

		expectr(ref i, TokenType.assign);

		var value = parseExpression(ref i);

		var end = expectr(ref i, TokenType.semicolon, ErrorCode.err_ExpectedStatementTerminator);

		return new SimpleAssignment(
			getLocation(target, end),
			target,
			value
		);
	}

	private parseCompoundAssignment(ref i, target)
	{
		/* Syntax:
		 *   compound-assignment-statement:
		 *     primary-expression compound-assignment-operator expression ';'
		 *   compound-assignment-operator: one of
		 *     '+='  '-='   '|='   '*='   '/='   '%='  '&='
		 *     '^='  '::='  '<<='  '>>='  '**='
		 */
		ensureAssignable(target);

		var op = typeToBinaryOperator[lex[i].type];
		i += 1;

		var value = parseExpression(ref i);

		var end = expectr(ref i, TokenType.semicolon, ErrorCode.err_ExpectedStatementTerminator);

		return new CompoundAssignment(
			getLocation(target, end),
			target, op, value
		);
	}

	private parseParallelAssignment(ref i, firstTarget)
	{
		/* Syntax:
		 *   parallel-assignment-statement:
		 *     primary-expression-list ',' primary-expression '=' expression-list ';'
		 *   primary-expression-list:
		 *     primary-expression
		 *     primary-expression-list ',' primary-expression
		 */
		// Parse all the target expressions first, then expect '=', then check
		// assignability. It feels like bad practice to verify each target is
		// assignable before we have even seen an equals sign.

		var targets = new List(2);
		targets.add(firstTarget);
		while acceptr(ref i, TokenType.comma):
			targets.add(parsePrimaryExpression(ref i));

		expectr(ref i, TokenType.assign, ErrorCode.err_ExpectedParallelAssignment);

		targets.each(ensureAssignable);
		targets = new NodeList(targets);

		var values = new List(1);
		do
		{
			values.add(parseExpression(ref i));
		} while acceptr(ref i, TokenType.comma);
		values = new NodeList(values);

		var end = expectr(ref i, TokenType.semicolon, ErrorCode.err_ExpectedStatementTerminator);

		if values.length != 1 and values.length != targets.length:
			recoverableError(end, ErrorCode.err_ParallelAssignmentWrongValueCount, [targets.length, values.length]);

		return new ParallelAssignment(
			getLocation(firstTarget, end),
			targets, values
		);
	}

	//</region>

	//<region: Expressions>

	/// Summary: Parses an argument list at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Param endToken: (optional) A {TokenType} that marks the end of the argument list.
	///          This is necessary because argument lists can have trailing commas. The
	///          default is {TokenType.parenClose}.
	/// Param allowEmpty: (optional) True if an empty argument list is permitted. The
	///          default is true.
	/// Param allowRefArgs: (optional) True if `ref` arguments are permitted. The default
	///          is true.
	/// Returns: An {ArgumentList} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'argument-list' nonterminal.
	public parseArgumentList(ref i, endToken = TokenType.parenClose,
		allowEmpty = true, allowRefArgs = true)
	{
		/* Syntax:
		 *   argument-list:
		 *     arguments ','?
		 *   arguments:
		 *     argument
		 *     arguments ',' argument
		 *   argument:
		 *     expression
		 *     'ref' primary-expression
		 * Additional notes:
		 *   This method also parses empty argument lists (hence the `endToken` parameter)
		 *   and `allowEmpty` can be used to disable this behaviour. Similarly, `allowRefArgs`
		 *   can be used to disable 'ref' arguments, which are not permitted in indexer
		 *   access expressions.
		 */
		if accept(i, endToken)
		{
			// Note: don't skip the end token
			if not allowEmpty:
				recoverableError(lex[i], ErrorCode.err_ExpectedArgument);
			return EmptyLists.argument;
		}

		var arguments = new List(2);
		var hasRefArguments = false;
		do
		{
			var arg;
			if accept(i, TokenType.\ref)
			{
				if not allowRefArgs:
					recoverableError(lex[i], ErrorCode.err_RefArgumentNotAllowed);

				arg = parseRefExpression(ref i);
				hasRefArguments = true;
			}
			else
			{
				arg = parseExpression(ref i);
			}
			arguments.add(arg);
		} while acceptr(ref i, TokenType.comma) and
			not accept(i, endToken);

		return new ArgumentList(arguments, hasRefArguments);
	}

	/// Summary: Parses a `ref` expression at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: A {RefExpression} from the tokens at the starting index.
	/// Remarks: This method parses part of the 'argument' nonterminal.
	public parseRefExpression(ref i)
	{
		/* Syntax:
		 *   argument:
		 *     ...
		 *     'ref' primary-expression
		 */
		var start = expectr(ref i, TokenType.\ref);
		var inner = parsePrimaryExpression(ref i);
		ensureAssignable(inner);
		return new RefExpression(getLocation(start, inner), inner);
	}

	/// Summary: Parses an expression at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: An {Expression} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'expression' nonterminal.
	public parseExpression(ref i)
	{
		/* Syntax:
		 *   expression:
		 *     conditional-expression
		 *     use-in-expression
		 */
		if accept(i, TokenType.\use):
			return parseUseInExpression(ref i);

		return parseConditionalExpression(ref i);
	}

	/// Summary: Parses a conditional (ternary operator) expression at the specified
	///          token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: An {Expression} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'conditional-expression' nonterminal.
	public parseConditionalExpression(ref i)
	{
		/* Syntax:
		 *   conditional-expression:
		 *     null-coalescing-expression
		 *     null-coalescing-expression '?' expression ':' expression
		 */
		var left = parseNullCoalescingExpression(ref i);

		if acceptr(ref i, TokenType.question)
		{
			var truePart = parseExpression(ref i);
			expectr(ref i, TokenType.colon);
			var falsePart = parseExpression(ref i);

			left = new ConditionalExpression(
				getLocation(left, falsePart),
				left, truePart, falsePart
			);
		}

		return left;
	}

	/// Summary: Parses a null-coalescing expression at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: An {Expression} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'null-coalescing-expression'
	///          nonterminal.
	public parseNullCoalescingExpression(ref i)
	{
		/* Syntax:
		 *   null-coalescing-expression:
		 *     null-or-expression
		 *     null-or-expression '??' null-coalescing-expression
		 */
		var left = parseNullOrExpression(ref i);

		if acceptr(ref i, TokenType.nullCoalescing)
		{
			var right = parseNullCoalescingExpression(ref i);
			left = new NullCoalescingExpression(
				getLocation(left, right),
				left, right
			);
		}

		return left;
	}

	/// Summary: Parses a null-or expression at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: An {Expression} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'null-or-expression' nonterminal.
	public parseNullOrExpression(ref i)
	{
		/* Syntax:
		 *   null-or-expression:
		 *     conditional-or-expression
		 *     conditional-or-expression '?!' null-or-expression
		 */
		var left = parseConditionalOrExpression(ref i);

		if acceptr(ref i, TokenType.nullOr)
		{
			var right = parseNullOrExpression(ref i);
			left = new NullOrExpression(
				getLocation(left, right),
				left, right
			);
		}

		return left;
	}

	/// Summary: Parses a conditional OR expression at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: An {Expression} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'conditional-or-expression' nonterminal.
	public parseConditionalOrExpression(ref i)
	{
		/* Syntax:
		 *   conditional-or-expression:
		 *     conditional-exclusive-or-expression
		 *     conditional-or-expression 'or' conditional-exclusive-or-expression
		 */
		var left = parseConditionalXorExpression(ref i);

		while acceptr(ref i, TokenType.\or)
		{
			var right = parseConditionalXorExpression(ref i);
			left = new ConditionalOrExpression(
				getLocation(left, right),
				left, right
			);
		}

		return left;
	}

	/// Summary: Parses a conditional XOR expression at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: An {Expression} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'conditional-xor-expression' nonterminal.
	public parseConditionalXorExpression(ref i)
	{
		/* Syntax:
		 *   conditional-exclusive-or-expression:
		 *     conditional-and-expression
		 *     conditional-exclusive-or-expression 'xor' conditional-and-expression
		 */
		var left = parseConditionalAndExpression(ref i);

		while acceptr(ref i, TokenType.\xor)
		{
			var right = parseConditionalAndExpression(ref i);
			left = new ConditionalXorExpression(
				getLocation(left, right),
				left, right
			);
		}

		return left;
	}

	/// Summary: Parses a conditional AND expression at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: An {Expression} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'conditional-and-expression' nonterminal.
	public parseConditionalAndExpression(ref i)
	{
		/* Syntax:
		 *   conditional-and-expression:
		 *     equality-expression
		 *     conditional-and-expression 'and' equality-expression
		 */
		var left = parseEqualityExpression(ref i);

		while acceptr(ref i, TokenType.\and)
		{
			var right = parseEqualityExpression(ref i);
			left = new ConditionalAndExpression(
				getLocation(left, right),
				left, right
			);
		}

		return left;
	}

	/// Summary: Parses an equality expression at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: An {Expression} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'equality-expression' nonterminal.
	public parseEqualityExpression(ref i)
	{
		/* Syntax:
		 *   equality-expression:
		 *     relational-expression
		 *     equality-expression '==' relational-expression
		 *     equality-expression '!=' relational-expression
		 *     equality-expression 'is' 'not'? type
		 *     equality-expression 'is' 'not'? 'null'
		 *     equality-expression 'not'? 'refeq' relational-expression
		 */
		var left = parseRelationalExpression(ref i);

		if acceptr(ref i, TokenType.\is)
		{
			var negated = acceptr(ref i, TokenType.\not);
			var type;
			if not acceptr(ref i, TokenType.\null):
				type = parseTypeName(ref i);

			return new TypeTestExpression(
				getLocation(left, lex[i - 1]),
				left, type, negated
			);
		}

		while accept(i, TokenType.doubleEqual, TokenType.notEqual, TokenType.\refeq) or
			accept(i, TokenType.\not) and accept(i + 1, TokenType.\refeq)
		{
			var type = lex[i].type;
			var op;
			if type == TokenType.\not
			{
				// not refeq
				i += 2; // skip 'not refeq'
				op = BinaryOperator.refInequality;
			}
			else
			{
				i += 1; // skip operator
				op = typeToBinaryOperator[type];
			}

			var right = parseRelationalExpression(ref i);

			left = new BinaryExpression(
				getLocation(left, right),
				left, op, right
			);
		}

		return left;
	}

	/// Summary: Parses a relational expression at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: An {Expression} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'relational-expression' nonterminal.
	public parseRelationalExpression(ref i)
	{
		/* Syntax:
		 *   relational-expression:
		 *     shift-expression
		 *     relational-expression < shift-expression
		 *     relational-expression > shift-expression
		 *     relational-expression <= shift-expression
		 *     relational-expression >= shift-expression
		 *     relational-expression <=> shift-expression
		 */
		var left = parseShiftExpression(ref i);

		while acceptAny(i, relationalOperators)
		{
			var op = typeToBinaryOperator[lex[i].type];
			i += 1;

			var right = parseShiftExpression(ref i);

			left = new BinaryExpression(
				getLocation(left, right),
				left, op, right
			);
		}

		return left;
	}

	/// Summary: Parses a shift expression at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: An {Expression} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'shift-expression' nonterminal.
	public parseShiftExpression(ref i)
	{
		/* Syntax:
		 *   shift-expression:
		 *     additive-expression
		 *     shift-expression << additive-expression
		 *     shift-expression >> additive-expression
		 */
		var left = parseAdditiveExpression(ref i);

		while accept(i, TokenType.shiftLeft, TokenType.shiftRight)
		{
			var op = typeToBinaryOperator[lex[i].type];
			i += 1;

			var right = parseAdditiveExpression(ref i);

			left = new BinaryExpression(
				getLocation(left, right),
				left, op, right
			);
		}

		return left;
	}

	/// Summary: Parses an additive expression at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: An {Expression} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'additive-expression' nonterminal.
	public parseAdditiveExpression(ref i)
	{
		/* Syntax:
		 *   additive-expression:
		 *     exclusive-or-expression
		 *     additive-expression '+' exclusive-or-expression
		 *     additive-expression '-' exclusive-or-expression
		 *     additive-expression '|' exclusive-or-expression
		 */
		var left = parseXorExpression(ref i);

		while accept(i, TokenType.plus, TokenType.minus, TokenType.pipe)
		{
			var op = typeToBinaryOperator[lex[i].type];
			i += 1;

			var right = parseXorExpression(ref i);

			left = new BinaryExpression(
				getLocation(left, right),
				left, op, right
			);
		}

		return left;
	}

	/// Summary: Parses a bitwise XOR expression at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: An {Expression} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'xor-expression' nonterminal.
	public parseXorExpression(ref i)
	{
		/* Syntax:
		 *   exclusive-or-expression:
		 *     multiplicative-expression
		 *     exclusive-or-expression '^' multiplicative-expression
		 */
		var left = parseMultiplicativeExpression(ref i);

		while acceptr(ref i, TokenType.caret)
		{
			var right = parseMultiplicativeExpression(ref i);
			left = new BinaryExpression(
				getLocation(left, right),
				left, BinaryOperator.bitwiseXor, right
			);
		}

		return left;
	}

	/// Summary: Parses a multiplicative expression at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: An {Expression} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'multiplicative-expression' nonterminal.
	public parseMultiplicativeExpression(ref i)
	{
		/* Syntax:
		 *   multiplicative-expression:
		 *     concatenation-expression
		 *     multiplicative-expression '*' concatenation-expression
		 *     multiplicative-expression '/' concatenation-expression
		 *     multiplicative-expression '%' concatenation-expression
		 *     multiplicative-expression '&' concatenation-expression
		 */
		var left = parseConcatenationExpression(ref i);

		while acceptAny(i, multiplicativeOperators)
		{
			var op = typeToBinaryOperator[lex[i].type];
			i += 1;

			var right = parseConcatenationExpression(ref i);

			left = new BinaryExpression(
				getLocation(left, right),
				left, op, right
			);
		}

		return left;
	}

	/// Summary: Parses a concatenation expression at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: An {Expression} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'concatenation-expression' nonterminal.
	public parseConcatenationExpression(ref i)
	{
		/* Syntax:
		 *   concatenation-expression:
		 *     unary-expression
		 *     concatenation-expression '::' unary-expression
		 */
		var left = parseUnaryExpression(ref i);

		while acceptr(ref i, TokenType.concatenate)
		{
			var right = parseUnaryExpression(ref i);
			left = new BinaryExpression(
				getLocation(left, right),
				left, BinaryOperator.concatenation, right
			);
		}

		return left;
	}

	/// Summary: Parses a unary expression at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: An {Expression} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'unary-expression' nonterminal.
	public parseUnaryExpression(ref i)
	{
		/* Syntax:
		 *   unary-expression:
		 *     exponential-expression
		 *     '+' unary-expression
		 *     '-' unary-expression
		 *     '~' unary-expression
		 *     'not' unary-expression
		 */
		if acceptAny(i, unaryOperators)
		{
			var start = lex[i];
			var op = typeToUnaryOperator[start.type];
			i += 1;

			var inner = parseUnaryExpression(ref i);
			return new UnaryExpression(
				getLocation(start, inner),
				op, inner
			);
		}

		return parseExponentialExpression(ref i);
	}

	/// Summary: Parses an exponential expression at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: An {Expression} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'exponential-expression' nonterminal.
	public parseExponentialExpression(ref i)
	{
		/* Syntax:
		 *   exponential-expression:
		 *     function-application-expression
		 *     function-application-expression '**' exponential-expression
		 */
		var left = parseFunctionApplicationExpression(ref i);

		if acceptr(ref i, TokenType.power)
		{
			var right = parseExponentialExpression(ref i);
			left = new BinaryExpression(
				getLocation(left, right),
				left, BinaryOperator.exponentiation, right
			);
		}

		return left;
	}

	/// Summary: Parses a function application expression at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: An {Expression} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'function-application-expression'
	///          nonterminal.
	public parseFunctionApplicationExpression(ref i)
	{
		/* Syntax:
		 *   function-application-expression:
		 *     primary-expression
		 *     primary-expression '->' concatenation-expression
		 */
		var left = parsePrimaryExpression(ref i);

		if acceptr(ref i, TokenType.funcApplication)
		{
			var right = parseConcatenationExpression(ref i);
			left = new BinaryExpression(
				getLocation(left, right),
				left, BinaryOperator.functionApplication, right
			);
		}

		return left;
	}

	/// Summary: Parses a primary expression at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: An {Expression} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'primary-expression' nonterminal.
	public parsePrimaryExpression(ref i)
	{
		/* Syntax:
		 *   primary-expression:
		 *     literal
		 *     simple-name
		 *     parenthesized-expression
		 *     member-access
		 *     global-access
		 *     invocation-expression
		 *     indexer-access
		 *     safe-access
		 *     this-access
		 *     base-access
		 *     object-creation-expression
		 *     iterator-lookup-expression
		 *     typeof-expression
		 *     list-creation-expression
		 *     hash-creation-expression
		 *     lambda-expression
		 *   member-access:
		 *     primary-expression '.' identifier
		 *   invocation-expression:
		 *     primary-expression '(' argument-list? ')'
		 *   indexer-access:
		 *     primary-expression '[' argument-list ']'
		 *   safe-access:
		 *     primary-expression safe-start-component safe-access-chain?
		 *   iterator-lookup-expression:
		 *     primary-expression '.' 'iter'
		 * Additional notes:
		 *   Of the expression kinds defined above, some begin with a primary-expression
		 *   (e.g. member-access, indexer-access, invocation-expression, safe-access).
		 *   The other kinds of expressions are considered atomic, and are parsed by
		 *   parseAtomicExpression.
		 *
		 *   Specifically, parseAtomicExpression takes care of the following kinds:
		 *     literal
		 *     simple-name
		 *     parenthesized-expression
		 *     global-access
		 *     this-access
		 *     base-access
		 *     object-creation-expression
		 *     typeof-expression
		 *     list-creation-expression
		 *     hash-creation-expression
		 *     lambda-expression
		 *   which leaves this method with:
		 *     member-access
		 *     invocation-expression
		 *     indexer-access
		 *     safe-access
		 *     iterator-lookup-expression
		 *
		 *   For the sake of simplicity, and because the spec treats them this way, this
		 *   method parses a safe-access as if the safe-start-component were part of the
		 *   safe-access-chain.
		 */
		var inner = parseAtomicExpression(ref i);

		while acceptAny(i, primaryExpressionStarters)
		{
			if acceptr(ref i, TokenType.dot)
			{
				// member-access or iterator-lookup-expression
				if acceptr(ref i, TokenType.\iter)
				{
					inner = new IteratorAccessExpression(
						getLocation(inner, lex[i - 1]),
						inner
					);
				}
				else
				{
					var name = expectr(ref i, TokenType.identifier, ErrorCode.err_ExpectedMemberToAccess);
					inner = new MemberAccessExpression(
						getLocation(inner, name),
						inner, name
					);
				}
			}
			else if acceptr(ref i, TokenType.parenOpen)
			{
				// invocation-expression
				var arguments = parseArgumentList(ref i);
				var end = expectr(ref i, TokenType.parenClose);
				inner = new InvocationExpression(
					getLocation(inner, end),
					inner, arguments
				);
			}
			else if acceptr(ref i, TokenType.squareOpen)
			{
				// indexer-access
				var arguments = parseArgumentList(
					ref i,
					/*endToken=*/ TokenType.squareClose,
					/*allowEmpty=*/ false,
					/*allowRefArgs=*/ false
				);
				var end = expectr(ref i, TokenType.squareClose);
				inner = new IndexerAccessExpression(
					getLocation(inner, end),
					inner, arguments
				);
			}
			else
			{
				// safe-access
				var chain = parseSafeAccessChain(ref i);
				inner = new SafeAccessExpression(
					getLocation(inner, lex[i - 1]),
					inner, chain
				);
			}
		}

		return inner;
	}

	private parseAtomicExpression(ref i)
	{
		/* Syntax:
		 *   atomic-expression:   (not part of grammar)
		 *     literal
		 *     simple-name
		 *     parenthesized-expression
		 *     global-access
		 *     this-access
		 *     base-access
		 *     object-creation-expression
		 *     typeof-expression
		 *     list-creation-expression
		 *     hash-creation-expression
		 *     lambda-expression
		 *     extension-expression    (non-standard extension, not in grammar)
		 *   simple-name:
		 *     identifier
		 *   parenthesized-expression:
		 *     '(' expression ')'
		 *   global-access:
		 *     'global' '.' identifier
		 *   this-access:
		 *     'this'
		 *   base-access:
		 *     'base'
		 *   typeof-expression:
		 *     'typeof' '(' expression ')'
		 *   extension-expression:
		 *     named-constant-expression
		 *     get-argc-expression
		 *   get-argc-expression:
		 *     '__get_argc'
		 * Additional notes:
		 *   An atomic expression is one that does not begin with a primary-expression.
		 *   All expressions contain at least one atomic expression.
		 */
		var start = lex[i];

		var type = start.type;
		if type == TokenType.\new:
			return parseObjectCreationExpression(ref i);
		if type == TokenType.squareOpen:
			return parseListCreationExpression(ref i);
		if type == TokenType.curlyOpen:
			return parseHashCreationExpression(ref i);
		if type == TokenType.at:
			return parseLambdaExpression(ref i);

		// Remaining: simple-name, parenthesized-expression, this-access, base-access,
		//            typeof-expression, global-access, named-constant-expression,
		//            get-argc-expression.
		// We can always skip the first token of these.
		i += 1; // See?

		if start.match(TokenType.literal):
			return literalFuncs[type](start);
		if type == TokenType.identifier
		{
			if useExtensions
			{
				if start.contextualType == ContextualType.namedConst:
					return parseNamedConstantExpression(ref i);
				if start.contextualType == ContextualType.getArgc:
					return new GetArgumentCountExpression(start.location);
			}
			return new SimpleNameExpression(start.location, start);
		}
		if type == TokenType.parenOpen
		{
			var inner = parseExpression(ref i);
			var end = expectr(ref i, TokenType.parenClose);
			return new ParenthesizedExpression(getLocation(start, end), inner);
		}
		if type == TokenType.\this:
			return new ThisAccessExpression(start.location);
		if type == TokenType.\base:
			return new BaseAccessExpression(start.location);
		if type == TokenType.\typeof
		{
			expectr(ref i, TokenType.parenOpen);
			var inner = parseExpression(ref i);
			var end = expectr(ref i, TokenType.parenClose);
			return new TypeOfExpression(getLocation(start, end), inner);
		}
		if type == TokenType.\global
		{
			expectr(ref i, TokenType.dot);
			var end = expectr(ref i, TokenType.identifier);
			return new GlobalAccessExpression(getLocation(start, end), end);
		}

		fatalError(start, ErrorCode.err_ExpectedPrimaryExpression, [start]);
	}

	private parseNamedConstantExpression(ref i)
	{
		/* Syntax:
		 *   named-constant-expression:   (non-standard extension)
		 *     '__named_const' '(' identifier ':' identifier ')'
		 * Additional notes:
		 *   This method is only ever called when '__named_const' has already been seen.
		 *   Therefore, we don't check for that here. Also, this method is called with i
		 *   set to one past the '__named_const' keyword.
		 */
		var start = lex[i - 1];
		expectr(ref i, TokenType.parenOpen);

		var type = expectr(ref i, TokenType.identifier);
		expectr(ref i, TokenType.colon);
		var value = expectr(ref i, TokenType.identifier);

		var end = expectr(ref i, TokenType.parenClose);

		return new NamedConstantExpression(
			getLocation(start, end),
			type, value
		);
	}

	/// Summary: Parses an object creation expression at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: An {ObjectCreationExpression} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'object-creation-expression'
	///          nonterminal.
	public parseObjectCreationExpression(ref i)
	{
		/* Syntax:
		 *   object-creation-expression:
		 *     'new' type '(' argument-list? ')' object-or-collection-initializer?
		 *     'new' type object-or-collection-initializer
		 */
		var start = expectr(ref i, TokenType.\new);

		var type = parseTypeName(ref i);

		var arguments, end;
		if acceptr(ref i, TokenType.parenOpen)
		{
			arguments = parseArgumentList(ref i);
			end = expectr(ref i, TokenType.parenClose);
		}
		else
		{
			arguments = EmptyLists.argument;
			expect(i, TokenType.\with, ErrorCode.err_ExpectedConstructorArgumentsOrInitializer);
		}

		var initializer;
		if acceptr(ref i, TokenType.\with)
		{
			initializer = parseObjectOrCollectionInitializer(ref i);
			end = initializer;
		}

		return new ObjectCreationExpression(
			getLocation(start, end),
			type, arguments, initializer
		);
	}

	private parseObjectOrCollectionInitializer(ref i)
	{
		/* Syntax:
		 *   object-or-collection-initializer:
		 *     object-initializer
		 *     collection-initializer
		 * Additional notes:
		 *   This method is called with 'i' just past the 'with' keyword. We should therefore
		 *   not expect it here.
		 */
		if accept(i, TokenType.squareOpen):
			return parseCollectionInitializer(ref i);
		else:
			return parseObjectInitializer(ref i);
	}

	private parseObjectInitializer(ref i)
	{
		/* Syntax:
		 *   object-initializer:
		 *     'with' '{' member-initializer-list? '}'
		 *     'with' '{' member-initializer-list ',' '}'
		 *   member-initializer-list:
		 *     member-initializer
		 *     member-initializer-list ',' member-initializer
		 *   member-initializer:
		 *     identifier ':' expression
		 * Additional notes:
		 *   This method is called with 'i' just past the 'with' keyword.
		 *   We should therefore not expect it here.
		 */
		var start = expectr(ref i, TokenType.curlyOpen);

		var members = EmptyLists.node;
		if not accept(i, TokenType.curlyClose)
		{
			members = new List(2);
			do
			{
				var memberName = expectr(ref i, TokenType.identifier);
				expectr(ref i, TokenType.colon);
				var memberValue = parseExpression(ref i);

				members.add(
					new MemberInitializer(
						getLocation(memberName, memberValue),
						memberName, memberValue
					)
				);
			} while acceptr(ref i, TokenType.comma) and
				not accept(i, TokenType.curlyClose);
			members = new NodeList(members);
		}

		var end = expectr(ref i, TokenType.curlyClose);

		return new ObjectInitializer(getLocation(start, end), members);
	}

	private parseCollectionInitializer(ref i)
	{
		/* Syntax:
		 *   collection-initializer:
		 *     'with' '[' element-initializer-list? ']'
		 *     'with' '[' element-initializer-list ',' ']'
		 * Additional notes:
		 *   This method is called with 'i' just past the 'with' keyword. We should therefore
		 *   not expect it here.
		 */
		var start = expectr(ref i, TokenType.squareOpen);

		var elements = EmptyLists.node;
		if not accept(i, TokenType.squareClose)
		{
			elements = parseElementInitializers(ref i);
		}

		do
		{
			var end = expectr(ref i, TokenType.squareClose);
			return new CollectionInitializer(getLocation(start, end), elements);
		};
	}

	private parseElementInitializers(ref i)
	{
		/* Syntax:
		 *   element-initializer-list:
		 *     element-initializer
		 *     element-initializer-list ',' element-initializer
		 *   element-initializer:
		 *     expression
		 *     '(' expression-list ')'
		 */
		var elements = new List(2);
		do
		{
			var argStart = lex[i], argEnd;
			var arguments;
			if acceptr(ref i, TokenType.parenOpen)
			{
				arguments = new List(2);
				if not accept(i, TokenType.parenClose):
					do
					{
						arguments.add(parseExpression(ref i));
					} while acceptr(ref i, TokenType.comma) and
						not accept(i, TokenType.parenClose);

				argEnd = expectr(ref i, TokenType.parenClose);
			}
			else
			{
				arguments = parseExpression(ref i);
				argEnd = arguments;
			}
			arguments = new NodeList(arguments);

			elements.add(
				new ElementInitializer(getLocation(argStart, argEnd), arguments)
			);
		} while acceptr(ref i, TokenType.comma) and
			not accept(i, TokenType.squareClose);
		elements = new NodeList(elements);

		return elements;
	}

	/// Summary: Parses a list creation expression at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: A {ListCreationExpression} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'list-creation-expression' nonterminal.
	public parseListCreationExpression(ref i)
	{
		/* Syntax:
		 *   list-creation-expression:
		 *     '[' expression-list? ']'
		 *     '[' expression-list ',' ']'
		 */
		var start = expectr(ref i, TokenType.squareOpen), end;

		if accept(i, TokenType.squareClose)
		{
			end = lex[i];
			i += 1;
			return new ListCreationExpression(getLocation(start, end), EmptyLists.node);
		}

		var values = new List(3);
		do
		{
			values.add(parseExpression(ref i));
		} while acceptr(ref i, TokenType.comma) and
			not accept(i, TokenType.squareClose);
		values = new NodeList(values);

		end = expectr(ref i, TokenType.squareClose);

		return new ListCreationExpression(
			getLocation(start, end),
			values
		);
	}

	/// Summary: Parses a hash creation expression at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: An {HashCreationExpression} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'hash-creation-expression' nonterminal.
	public parseHashCreationExpression(ref i)
	{
		/* Syntax:
		 *   hash-creation-expression:
		 *     '{' hash-member-list? '}'
		 *     '{' hash-member-list ',' '}'
		 *   hash-member-list:
		 *     hash-member
		 *     hash-member-list ',' hash-member
		 */
		var start = expectr(ref i, TokenType.curlyOpen), end;
		if accept(i, TokenType.curlyClose)
		{
			end = lex[i];
			i += 1;
			return new HashCreationExpression(getLocation(start, end), EmptyLists.node);
		}

		var members = new List(2);
		do
		{
			members.add(parseHashMember(ref i));
		} while acceptr(ref i, TokenType.comma) and
			not accept(i, TokenType.curlyClose);
		members = new NodeList(members);

		end = expectr(ref i, TokenType.curlyClose);

		return new HashCreationExpression(getLocation(start, end), members);
	}

	private parseHashMember(ref i)
	{
		/* Syntax:
		 *   hash-member:
		 *     hash-key ':' expression
		 *   hash-key:
		 *     expression
		 */
		var key = parseExpression(ref i);

		expectr(ref i, TokenType.colon);

		var value = parseExpression(ref i);

		return new HashMember(
			getLocation(key, value),
			key, value
		);
	}

	/// Summary: Parses a lambda expression at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: An {LambdaExpression} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'lambda-expression' nonterminal.
	public parseLambdaExpression(ref i)
	{
		/* Syntax:
		 *   lambda-expression:
		 *     simple-lambda-expression
		 *     lambda-member-expression
		 *     lambda-operator-expression
		 *   simple-lambda-expression:
		 *     '@' lambda-parameters? '=>' expression
		 *     '@' lambda-parameters? block
		 *   lambda-member-expression:
		 *     '@' lambda-member-access lambda-member safe-access-chain?
		 *   lambda-member-access: one of
		 *     '?.'  '.'
		 *   lambda-member:
		 *     identifier
		 *     'iter'
		 *   lambda-operator-expression:
		 *     '@' lambda-operator
		 *   lambda-operator: one of
		 *     '+'  '-'   '|'   '^'    '*'    '/'    '%'    '&'   '**'
		 *     '<<' '>>'  '=='  '!='   '<=>'  '<'    '>'    '<='  '>='
		 *     '~'  '->'  '::'  'not'  'or'   'xor'  'and'
		 * Additional notes:
		 *   The lambda-operator symbol is represented by the TokenType.lambdaOperator
		 *   category.
		 */
		var start = expectr(ref i, TokenType.at);

		// Is it a lambda-operator-expression?
		if accept(i, TokenType.lambdaOperator)
		{
			var op = lex[i];
			i += 1;
			return new LambdaOperatorExpression(
				getLocation(start, op),
				typeToLambdaOperator[op.type]
			);
		}

		// How about a lambda-member-expression?
		if accept(i, TokenType.dot, TokenType.safeAccess)
		{
			var members = parseSafeAccessChain(ref i);
			return new LambdaMemberExpression(
				getLocation(start, lex[i - 1]),
				members
			);
		}

		if not acceptAny(i, lambdaStarters):
			fatalError(lex[i], ErrorCode.err_InvalidLambdaExpression);

		// Must be a simple-lambda-expression

		// Parameters
		var parameters = parseLambdaParameterList(ref i);

		// Body
		var body;
		if acceptr(ref i, TokenType.fatArrow):
			body = parseExpression(ref i);
		else:
			body = parseBlock(ref i);

		return new SimpleLambdaExpression(
			getLocation(start, body),
			parameters, body
		);
	}

	private parseLambdaParameterList(ref i)
	{
		/* Syntax:
		 *   lambda-parameters:
		 *     identifier
		 *     '(' parameter-list? ')'
		 * Additional notes:
		 *   This method treats the lambda-parameters as optional. If there
		 *   is no identifier or '(', an empty parameter list is returned.
		 */
		var parameters;

		if accept(i, TokenType.identifier)
		{
			var paramName = lex[i];
			parameters = new ParameterList([
				new Parameter(
					paramName.location,
					paramName, null, false, false
				)
			]);
			i += 1;
		}
		else if acceptr(ref i, TokenType.parenOpen)
		{
			parameters = parseParameterList(ref i);
			expectr(ref i, TokenType.parenClose);
		}
		else
		{
			parameters = EmptyLists.parameter;
		}

		return parameters;
	}

	private parseSafeAccessChain(ref i)
	{
		/* Syntax:
		 *   safe-access-chain:
		 *     safe-access-link
		 *     safe-access-chain safe-access-link
		 *   safe-access-link:
		 *     safe-member-access
		 *     safe-invocation
		 *     safe-indexer-access
		 *     safe-iterator-lookup
		 *     unsafe-member-access
		 *     unsafe-invocation
		 *     unsafe-indexer-access
		 *     unsafe-iterator-lookup
		 *   safe-member-access:
		 *     '?.' identifier
		 *   safe-invocation:
		 *     '?(' argument-list? ')'
		 *   safe-indexer-access:
		 *     '?[' argument-list ']'
		 *   safe-iterator-lookup:
		 *     '?.' 'iter'
		 *   unsafe-member-access:
		 *     '.' identifier
		 *   unsafe-invocation:
		 *     '(' argument-list? ')'
		 *   unsafe-indexer-access:
		 *     '[' argument-list ']'
		 *   unsafe-iterator-lookup:
		 *     '.' 'iter'
		 */
		var links = new List(1);
		while acceptAny(i, safeNodeStarters)
		{
			var start = lex[i];
			var type = start.type;
			i += 1;
			var isSafe =
				type == TokenType.safeAccess or
				type == TokenType.parenOpenSafe or
				type == TokenType.squareOpenSafe;
			var link;
			if type == TokenType.dot or type == TokenType.safeAccess
			{
				// safe-member-access, unsafe-member-access,
				// safe-iterator-lookup or unsafe-iterator-lookup
				if acceptr(ref i, TokenType.\iter)
				{
					link = new SafeIteratorAccess(
						getLocation(start, lex[i - 1]),
						isSafe
					);
				}
				else
				{
					var member = expectr(ref i, TokenType.identifier, ErrorCode.err_ExpectedMemberToAccess);
					link = new SafeMemberAccess(
						getLocation(start, member),
						isSafe, member
					);
				}
			}
			else if type == TokenType.parenOpen or type == TokenType.parenOpenSafe
			{
				// safe-invocation or unsafe-invocation
				var arguments = parseArgumentList(ref i);
				var end = expectr(ref i, TokenType.parenClose);
				link = new SafeInvocation(
					getLocation(start, end),
					isSafe, arguments
				);
			}
			else
			{
				// safe-indexer-access or unsafe-indexer-access
				var arguments = parseArgumentList(
					ref i,
					/*endToken=*/ TokenType.squareClose,
					/*allowEmpty=*/ false,
					/*allowRefArgs=*/ false
				);
				var end = expectr(ref i, TokenType.squareClose);
				link = new SafeIndexerAccess(
					getLocation(start, end),
					isSafe, arguments
				);
			}
			links.add(link);
		}

		return new NodeList(links);
	}

	/// Summary: Parses a `use-in` expression at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: A {UseInExpression} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'use-in-expression' nonterminal.
	public parseUseInExpression(ref i)
	{
		/* Syntax:
		 *   use-in-expression:
		 *     'use' use-in-variables 'in' expression
		 *   use-in-variables:
		 *     use-in-variable
		 *     use-in-variables ',' use-in-variable
		 *   use-in-variable:
		 *     identifier '=' expression
		 */
		var start = expectr(ref i, TokenType.\use);

		var variables = new List(1);
		do
		{
			var name = expectr(ref i, TokenType.identifier);
			expectr(ref i, TokenType.assign, ErrorCode.err_UseInVariableWithoutValue);
			var value = parseExpression(ref i);
			variables.add(
				new VariableDeclarator(
					getLocation(name, value),
					name, value
				)
			);
		} while acceptr(ref i, TokenType.comma);
		variables = new NodeList(variables);

		expectr(ref i, TokenType.\in);

		var expression = parseExpression(ref i);

		return new UseInExpression(
			getLocation(start, expression),
			variables, expression
		);
	}

	//</region>

	/// Summary: Parses a qualified name at the specified token index. A qualified name is
	///          a series of identifiers separated by dots.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: A {QualifiedName} containing one or more identifiers.
	/// Remarks: This method parses the grammar of the 'qualified-name' nonterminal.
	public parseQualifiedName(ref i)
	{
		/* Syntax:
		 *   qualified-name:
		 *     identifier
		 *     qualified-name '.' identifier
		 */
		var names = new List(3);
		do
		{
			var name = expectr(ref i, TokenType.identifier);
			names.add(name);
		} while acceptr(ref i, TokenType.dot);

		return new QualifiedName(names);
	}

	/// Summary: Parses a type name at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: A {TypeName} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'type' nonterminal.
	public parseTypeName(ref i)
	{
		/* Syntax:
		 *   type:
		 *     qualified-name
		 *     'global' '.' qualified-name
		 */
		var start = lex[i];
		var globalToken;
		if accept(i, TokenType.\global)
		{
			globalToken = start;
			i += 1;
			expectr(ref i, TokenType.dot);
		}

		var name = parseQualifiedName(ref i);

		return new TypeName(
			getLocation(start, lex[i - 1]),
			globalToken is not null,
			name
		);
	}

	/// Summary: Parses a parameter list at the specified token index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Param endToken: (optional) A {TokenType} that marks the end of the argument list.
	///          This is used only for performance reasons: if the starting token matches
	///          {endToken}, then a static, empty instance of {ParameterList} is returned.
	///          The default is {TokenType.parenClose}.
	/// Param allowEmpty: (optional) True if the parameter list is allowed to be empty.
	///          The default is true.
	/// Returns: A {ParameterList} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'parameter-list' nonterminal. It is
	///          also suitable in other situations that call for parameter lists, even if
	///          the grammar does not say 'parameter-list', such as the parameters of an
	///          indexer accessor or operator overload.
	public parseParameterList(ref i, endToken = TokenType.parenClose, allowEmpty = true)
	{
		/* Syntax:
		 *   parameter-list:
		 *     regular-parameters
		 *     optional-parameters
		 *     regular-parameters ',' optional-parameters
		 *   regular-parameters:
		 *     parameter
		 *     regular-parameters ',' parameter
		 *   parameter:
		 *     identifier
		 *     'ref' identifier
		 *     '...' identifier
		 *   optional-parameters:
		 *     optional-parameter
		 *     optional-parameters ',' optional-parameter
		 *   optional-parameter:
		 *     identifier '=' optional-parameter-value
		 *   optional-parameter-value:
		 *     constant-expression
		 *     '[' ']'
		 *     '{' '}'
		 * Additional notes:
		 *   The parameter allowEmpty can be used to disallow empty parameter lists.
		 *   This is relevant for some constructs, such as indexers.
		 *
		 *   Since `[]` and `{}` are valid expressions and constant-expression is defined
		 *   as expression, we use parseExpression to parse optional-parameter-value, and
		 *   verify the value later.
		 */
		if accept(i, endToken)
		{
			if not allowEmpty:
				recoverableError(lex[i], ErrorCode.err_ExpectedParameter);
			return EmptyLists.parameter;
		}

		var hasVariadicParam = false, optionalCount = 0;

		var parameters = new List(2);
		do
		{
			var start = lex[i];
			var isRef = acceptr(ref i, TokenType.\ref);
			var isVariadic = acceptr(ref i, TokenType.splat);

			var name = expectr(ref i, TokenType.identifier);

			var defaultValue = null;
			if acceptr(ref i, TokenType.assign)
			{
				defaultValue = parseExpression(ref i);
				optionalCount += 1;
			}
			else if optionalCount > 0
			{
				recoverableError(name, ErrorCode.err_RequiredParameterAfterOptional);
			}

			if isVariadic
			{
				if accept(i, TokenType.comma):
					recoverableError(lex[i], ErrorCode.err_VariadicMustBeLastParameter);
				if hasVariadicParam:
					recoverableError(name, ErrorCode.err_MultipleVariadicParameters);
				hasVariadicParam = true;
			}

			verifyParameter(
				name,
				isRef,
				isVariadic,
				defaultValue,
				/*hasThisPrefix=*/ false,
				optionalCount,
				hasVariadicParam
			);

			parameters.add(
				new Parameter(
					getLocation(start, lex[i - 1]),
					name, defaultValue, isVariadic, isRef
				)
			);
		} while acceptr(ref i, TokenType.comma);

		return new ParameterList(
			parameters,
			optionalCount,
			null, // refParameterCount
			hasVariadicParam
		);
	}

	/// Summary: Parses a constructor paremter list at the specified token index. This
	///          method should not be used to parse a general parameter list; see
	///          {parseParameterList} for that purpose.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: A {ParameterList} from the tokens at the starting index.
	/// Remarks: This method parses the grammar of the 'ctor-parameter-list' nonterminal.
	///          A constructor parameter list differs from a regular parameter list in that
	///          required, non-ref parameters can be prefixed with `this.`.
	public parseConstructorParameterList(ref i)
	{
		/* Syntax:
		 *   ctor-parameter-list:
		 *     regular-ctor-parameters
		 *     optional-ctor-parameters
		 *     ctor-parameters ',' optional-ctor-parameters
		 *   optional-ctor-parameters:
		 *     optional-ctor-parameter
		 *     optional-ctor-parameters ',' optional-ctor-parameter
		 *   optional-ctor-parameter:
		 *     identifier '=' optional-parameter-value
		 *     'this' '.' identifier '=' optional-parameter-value
		 *   regular-ctor-parameters:
		 *     ctor-parameter
		 *     regular-ctor-parameters ',' ctor-parameter
		 *   ctor-parameter:
		 *     identifier
		 *     'ref' identifier
		 *     '...' identifier
		 *     'this' '.' identifier
		 *     '...' 'this' '.' identifier
		 */
		if accept(i, TokenType.parenClose):
			return EmptyLists.parameter;

		var hasVariadicParam = false, optionalCount = 0;

		var parameters = new List(2);
		do
		{
			var start = lex[i];

			var isRef = acceptr(ref i, TokenType.\ref);
			var isVariadic = acceptr(ref i, TokenType.splat);

			var hasThisPrefix = acceptr(ref i, TokenType.\this);
			if hasThisPrefix:
				expectr(ref i, TokenType.dot);

			var name = expectr(ref i, TokenType.identifier);

			var defaultValue;
			if acceptr(ref i, TokenType.assign)
			{
				defaultValue = parseExpression(ref i);
				optionalCount += 1;
			}
			else if optionalCount
			{
				recoverableError(name, ErrorCode.err_RequiredParameterAfterOptional);
			}

			if isVariadic
			{
				if accept(i, TokenType.comma):
					recoverableError(lex[i], ErrorCode.err_VariadicMustBeLastParameter);
				if hasVariadicParam:
					recoverableError(name, ErrorCode.err_MultipleVariadicParameters);
				hasVariadicParam = true;
			}

			verifyParameter(
				name,
				isRef,
				isVariadic,
				defaultValue,
				hasThisPrefix,
				optionalCount,
				hasVariadicParam
			);

			var param;
			if hasThisPrefix:
				param = new ThisParameter(
					getLocation(start, lex[i - 1]),
					name, defaultValue, isVariadic
				);
			else:
				param = new Parameter(
					getLocation(start, lex[i - 1]),
					name, defaultValue, isVariadic, isRef
				);
			parameters.add(param);
		} while acceptr(ref i, TokenType.comma);

		return new ParameterList(
			parameters,
			optionalCount,
			null, // refParameterCount
			hasVariadicParam
		);
	}

	private verifyParameter(errorNode, isRef, isVariadic, defaultValue, hasThisPrefix, optionalCount, hasVariadicParam)
	{
			// Variadic, optional and 'this' parameters cannot be passed by reference
			if isRef
			{
				if isVariadic:
					recoverableError(errorNode, ErrorCode.err_CannotPassVariadicByRef);
				else if defaultValue:
					recoverableError(defaultValue, ErrorCode.err_CannotPassOptionalByRef);
				else if hasThisPrefix:
					recoverableError(errorNode, ErrorCode.err_CannotPassThisParameterByRef);
			}
			// Variadic parameters cannot have a default value
			if isVariadic and defaultValue:
				recoverableError(defaultValue, ErrorCode.err_VariadicParameterCannotBeOptional);
			// Cannot mix optional parameters and variadic parameters in the same parameter list
			if optionalCount and hasVariadicParam:
				recoverableError(errorNode, ErrorCode.err_CannotMixVariadicAndOptionalParameters);
	}

	/// Summary: Parses zero or more member modifiers at the specified index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Param modifiers:
	///          (optional) A {Modifiers} instance that is updated with the parsed
	///          modifiers, or null to construct a new instance.
	/// Returns: A {Modifiers} instance that contains the parsed modifiers. If {modifiers}
	///          is not null, the return value is the same instance as {modifiers}.
	public parseModifiers(ref i, modifiers = null)
	{
		/* Syntax:
		 *   No grammar as such. Parses a sequence of tokens matching
		 *   TokenType.memberModifier, which may include more modifiers
		 *   than the target member accepts.
		 *   Sequences of modifiers are used by most kinds of non-local
		 *   member definitions.
		 *   The `verify*` methods on `Modifiers` should be used to
		 *   verify that the modifiers are correct for the member.
		 */
		if modifiers is null:
			modifiers = new Modifiers();
		else:
			modifiers.clear();

		modifiers.annotations = parseAnnotations(ref i);

		while accept(i, TokenType.memberModifier)
		{
			var modifier = lex[i];
			modifierFuncs[modifier.type](this, modifiers, modifier);

			i += 1; // skip modifier
		}

		return modifiers;
	}

	/// Summary: Adds a modifier to the specified {Modifiers} instance.
	/// Param modifiers: The {Modifiers} instance to modify with the modifier.
	/// Param token: The {Token} containing the modifier.
	/// Param name: A string contaning the modifiers keyword, used only if a duplicate modifier
	///          error is needed.
	/// Param field: (ref) The {Modifiers} field to assign the token to.
	/// Returns: True if the modifier was added successfully; otherwise, false. This method can
	///          fail with a duplicate modifier error.
	/// Remarks: If {modifiers} is empty, the {Modifiers.start} token will be set as well.
	///
	///          To add an accessibility modifier, use {addAccessibilityModifier}, which emits an
	///          additional error if {modifiers} already has another accessibility modifier.
	///
	///          This method is called indirectly through {modifierFuncs}.
	private addModifier(modifiers, token, name, ref field)
	{
		if field is not null
		{
			recoverableError(token, ErrorCode.err_DuplicateModifier, [name]);
			return false;
		}

		field = token;
		if modifiers.start is null:
			modifiers.start = token;

		return true;
	}

	/// Summary: Adds an accessibility modifier to the specified {Modifiers} instance.
	/// Param modifiers: The {Modifiers} instance to modify with the modifier.
	/// Param token: The {Token} containing the modifier.
	/// Param name: A string containing the modifiers keyword, used only if a duplicate modifier
	///          error is needed.
	/// Param field: (ref) The {Modifiers} field to assign the token to.
	/// Returns: True if the modifier was added successfully; otherwise, false. This method can
	///          fail with a duplicate modifier error as well as a multiple accessibility
	///          modifier error.
	/// Remarks: If {modifiers} is empty, the {Modifiers.start} token will be set as well.
	///
	///          To add a non-accessibility modifier, use {addModifier}, which does not check
	///          whether {modifiers} already has another accessibility modifier.
	///
	///          This method is called indirectly through {modifierFuncs}.
	private addAccessibilityModifier(modifiers, token, name, ref field)
	{
		if field is not null
		{
			recoverableError(token, ErrorCode.err_DuplicateModifier, [name]);
			return false;
		}
		else if modifiers.hasAccessibility
		{
			recoverableError(token, ErrorCode.err_MultipleAccessibilityModifiers);
			return false;
		}

		field = token;
		if modifiers.start is null:
			modifiers.start = token;

		return true;
	}

	/// Summary: Parses zero or more global annotations at the specified index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: A {NodeList} of {Annotation} instances from the tokens at the starting
	///          index.
	public parseGlobalAnnotations(ref i)
	{
		/* Syntax:
		 *   global-annotations:
		 *     global-annotation
		 *     global-annotations global-annotation
		 */
		if not accept(i, TokenType.exclam):
			return EmptyLists.node;

		var annotations = new List(1);
		while accept(i, TokenType.exclam) and
			accept(i + 1, TokenType.\global) and
			accept(i + 2, TokenType.colon)
		{
			var annotation = parseAnnotationHelper(ref i, true);
			annotations.add(annotation);
		}
		annotations = new NodeList(annotations);

		return annotations;
	}

	/// Summary: Parses zero or more annotations at the specified index.
	/// Param i: (ref) The token index to start parsing at. Upon returning, this contains
	///          the index of the token that immediately follows the returned parse tree.
	/// Returns: A {NodeList} of {Annotation} instances from the tokens at the starting
	///          index.
	/// Remarks: In general, call {parseModifiers} instead of {parseAnnotations} if you want
	///          to parse member modifiers, and then use one of the `verify*` methods on
	///          the returned {Modifiers}. Calling this method directly can be useful when
	///          the member accepts no other modifiers than annotations  this is done, for
	///          instance, with enum fields.
	public parseAnnotations(ref i)
	{
		/* Syntax:
		 *   annotations:
		 *     member-annotation
		 *     annotations member-annotation
		 */
		if not accept(i, TokenType.exclam):
			return EmptyLists.node;

		var annotations = new List(1);
		while accept(i, TokenType.exclam)
		{
			var annotation = parseAnnotationHelper(ref i, false);
			annotations.add(annotation);
		}
		annotations = new NodeList(annotations);

		return annotations;
	}

	private parseAnnotationHelper(ref i, isGlobal)
	{
		/* Syntax:
		 *   member-annotation:
		 *     '!' type annotation-argument-list?
		 *   global-annotation:
		 *     '!' 'global' ':' type annotation-argument-list?
		 *   annotation-arguments-list:
		 *     '(' positional-annotation-arguments? ')'
		 *     '(' named-annotation-arguments ')'
		 *     '(' positional-annotation-arguments ',' named-annotation-arguments ')'
		 * Additional notes:
		 *   This method parses both member-annotation and global-annotation, depending on
		 *   whether isGlobal is true or false.
		 */
		var start = expectr(ref i, TokenType.exclam);

		if isGlobal
		{
			expectr(ref i, TokenType.\global);
			expectr(ref i, TokenType.colon);
		}

		var type = parseTypeName(ref i);

		var positionalArguments = EmptyLists.argument;
		var namedArguments = EmptyLists.node;

		if acceptr(ref i, TokenType.parenOpen) and not acceptr(ref i, TokenType.parenClose)
		{
			parseAnnotationArguments(ref i, ref positionalArguments, ref namedArguments);
			expectr(ref i, TokenType.parenClose);
		}

		return new Annotation(
			getLocation(start, lex[i - 1]),
			isGlobal,
			type,
			positionalArguments,
			namedArguments
		);
	}

	private parseAnnotationArguments(ref i, ref positionalArguments, ref namedArguments)
	{
		/* Syntax:
		 *   positional-annotation-arguments:
		 *     annotation-argument
		 *     positional-annotation-arguments ',' annotation-argument
		 *   named-annotation-arguments:
		 *     named-annotation-argument
		 *     named-annotation-arguments ',' named-annotation-argument
		 *   annotation-named-argument:
		 *     identifier ':' annotation-argument
		 *   annotation-argument:
		 *     expression
		 * Additional restrictions:
		 *   Each annotation-argument must be a constant expression or a simple-list-expression
		 *   containing only annotation-arguments. This is verified elsewhere.
		 */

		var _positionalArguments = new List(1);
		var _namedArguments = new List(1);

		do
		{
			var memberName;
			if accept(i, TokenType.identifier) and accept(i + 1, TokenType.colon)
			{
				memberName = lex[i];
				i += 2; // skip name and colon
			}

			var argument = parseExpression(ref i);

			if not memberName and not _namedArguments.isEmpty:
				recoverableError(argument, ErrorCode.err_PositionalAnnotationArgumentMustComeBeforeNamed);

			if memberName:
				_namedArguments.add(
					new MemberInitializer(
						getLocation(memberName, argument),
						memberName, argument
					)
				);
			else:
				_positionalArguments.add(argument);
		} while acceptr(ref i, TokenType.comma);

		positionalArguments = new ArgumentList(_positionalArguments);
		namedArguments = new NodeList(_namedArguments);
	}

	// Functions that set modifiers as they are being parsed.
	private static modifierFuncs = {
		TokenType.\public: @(parser, modifiers, token)
		{
			parser.addAccessibilityModifier(modifiers, token, "public", ref modifiers.\public);
		},
		TokenType.\internal: @(parser, modifiers, token)
		{
			parser.addAccessibilityModifier(modifiers, token, "internal", ref modifiers.\internal);
		},
		TokenType.\protected: @(parser, modifiers, token)
		{
			parser.addAccessibilityModifier(modifiers, token, "protected", ref modifiers.\protected);
		},
		TokenType.\private: @(parser, modifiers, token)
		{
			parser.addAccessibilityModifier(modifiers, token, "private", ref modifiers.\private);
		},
		TokenType.\static: @(parser, modifiers, token)
		{
			parser.addModifier(modifiers, token, "static", ref modifiers.\static);
		},
		TokenType.\abstract: @(parser, modifiers, token)
		{
			parser.addModifier(modifiers, token, "abstract", ref modifiers.\abstract);
		},
		TokenType.\inheritable: @(parser, modifiers, token)
		{
			parser.addModifier(modifiers, token, "inheritable", ref modifiers.\inheritable);
		},
		TokenType.\overridable: @(parser, modifiers, token)
		{
			parser.addModifier(modifiers, token, "overridable", ref modifiers.\overridable);
		},
		TokenType.\override: @(parser, modifiers, token)
		{
			parser.addModifier(modifiers, token, "override", ref modifiers.\override);
		},
	};

	// TokenTypes that denote the beginning of a jump statement.
	private static jumpStatementTypes = Set.fromCollection([
		TokenType.\return,
		TokenType.\yield,
		TokenType.\next,
		TokenType.\break,
		TokenType.\throw,
	]);

	private static typeToBinaryOperator = {
		TokenType.doubleEqual:  BinaryOperator.equality,
		TokenType.notEqual:     BinaryOperator.inequality,
		TokenType.\refeq:       BinaryOperator.refEquality,
		TokenType.less:         BinaryOperator.less,
		TokenType.greater:      BinaryOperator.greater,
		TokenType.lessEqual:    BinaryOperator.lessEqual,
		TokenType.greaterEqual: BinaryOperator.greaterEqual,
		TokenType.compare:      BinaryOperator.comparison,
		TokenType.shiftLeft:    BinaryOperator.shiftLeft,
		TokenType.shiftRight:   BinaryOperator.shiftRight,
		TokenType.plus:         BinaryOperator.addition,
		TokenType.minus:        BinaryOperator.subtraction,
		TokenType.pipe:         BinaryOperator.bitwiseOr,
		TokenType.caret:        BinaryOperator.bitwiseXor,
		TokenType.multiply:     BinaryOperator.multiplication,
		TokenType.divide:       BinaryOperator.division,
		TokenType.modulo:       BinaryOperator.modulo,
		TokenType.ampersand:    BinaryOperator.bitwiseAnd,
		TokenType.power:        BinaryOperator.exponentiation,
		// Compound assignment operators
		TokenType.plusAssign:       BinaryOperator.addition,
		TokenType.minusAssign:      BinaryOperator.subtraction,
		TokenType.pipeAssign:       BinaryOperator.bitwiseOr,
		TokenType.mulAssign:        BinaryOperator.multiplication,
		TokenType.divAssign:        BinaryOperator.division,
		TokenType.modAssign:        BinaryOperator.modulo,
		TokenType.ampAssign:        BinaryOperator.bitwiseAnd,
		TokenType.caretAssign:      BinaryOperator.bitwiseXor,
		TokenType.concatAssign:     BinaryOperator.concatenation,
		TokenType.shiftLeftAssign:  BinaryOperator.shiftLeft,
		TokenType.shiftRightAssign: BinaryOperator.shiftRight,
		TokenType.powerAssign:      BinaryOperator.exponentiation,
	};

	private static typeToUnaryOperator = {
		TokenType.plus:  UnaryOperator.plus,
		TokenType.minus: UnaryOperator.negation,
		TokenType.tilde: UnaryOperator.bitwiseNot,
		TokenType.\not:  UnaryOperator.booleanNot
	};

	private static typeToLambdaOperator = {
		TokenType.\or:             LambdaOperator.conditionalOr,
		TokenType.\xor:            LambdaOperator.conditionalXor,
		TokenType.\and:            LambdaOperator.conditionalAnd,
		TokenType.doubleEqual:     LambdaOperator.equality,
		TokenType.notEqual:        LambdaOperator.inequality,
		TokenType.less:            LambdaOperator.less,
		TokenType.lessEqual:       LambdaOperator.lessEqual,
		TokenType.greater:         LambdaOperator.greater,
		TokenType.greaterEqual:    LambdaOperator.greaterEqual,
		TokenType.compare:         LambdaOperator.comparison,
		TokenType.shiftLeft:       LambdaOperator.shiftLeft,
		TokenType.shiftRight:      LambdaOperator.shiftRight,
		TokenType.plus:            LambdaOperator.plus,
		TokenType.minus:           LambdaOperator.minus,
		TokenType.pipe:            LambdaOperator.bitwiseOr,
		TokenType.caret:           LambdaOperator.bitwiseXor,
		TokenType.multiply:        LambdaOperator.multiplication,
		TokenType.divide:          LambdaOperator.division,
		TokenType.modulo:          LambdaOperator.modulo,
		TokenType.ampersand:       LambdaOperator.bitwiseAnd,
		TokenType.power:           LambdaOperator.exponentiation,
		TokenType.funcApplication: LambdaOperator.functionApplication,
		TokenType.concatenate:     LambdaOperator.concatenation,
		TokenType.tilde:           LambdaOperator.bitwiseNot,
		TokenType.\not:            LambdaOperator.booleanNot,
	};

	private static relationalOperators = [
		TokenType.less,
		TokenType.greater,
		TokenType.lessEqual,
		TokenType.greaterEqual,
		TokenType.compare,
	];

	private static multiplicativeOperators = [
		TokenType.multiply,
		TokenType.divide,
		TokenType.modulo,
		TokenType.ampersand,
	];

	private static unaryOperators = [
		TokenType.plus,
		TokenType.minus,
		TokenType.tilde,
		TokenType.\not,
	];

	private static literalFuncs = {
		TokenType.\null:  @token => new NullLiteralExpression(token.location),
		TokenType.\false: @token => new BooleanLiteralExpression(token.location, false),
		TokenType.\true:  @token => new BooleanLiteralExpression(token.location, true),
		TokenType.int:    @token => new IntegerLiteralExpression(token.location, token.literalValue),
		TokenType.real:   @token => new RealLiteralExpression(token.location, token.literalValue),
		TokenType.string: @token => new StringLiteralExpression(token.location, token.literalValue),
		TokenType.char:   @token => new CharLiteralExpression(token.location, token.literalValue),
	};

	private static primaryExpressionStarters = [
		TokenType.dot,
		TokenType.parenOpen,
		TokenType.squareOpen,
		TokenType.safeAccess,
		TokenType.parenOpenSafe,
		TokenType.squareOpenSafe,
	];

	private static safeNodeStarters = [
		TokenType.dot,
		TokenType.parenOpen,
		TokenType.squareOpen,
		TokenType.safeAccess,
		TokenType.parenOpenSafe,
		TokenType.squareOpenSafe,
	];

	private static lambdaStarters = [
		TokenType.identifier,
		TokenType.parenOpen,
		TokenType.fatArrow,
		TokenType.curlyOpen,
	];
}
