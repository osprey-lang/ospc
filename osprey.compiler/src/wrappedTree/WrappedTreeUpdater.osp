use aves;
use osprey.compiler.parser;

namespace osprey.compiler.syntax.wrapped;

public abstract class WrappedTreeUpdater is WrappedTreeVisitor
{
	private isNotNull = @node => node is not null;

	private mapList(list, arg)
	{
		return list.map(@.accept(this, arg))
			.filter(isNotNull);
	}

	public overridable updateNodeList(list, arg)
	{
		return new NodeList(mapList(list, arg));
	}

	public overridable updateArgumentList(list, arg)
	{
		return new ArgumentList(mapList(list, arg));
	}

	public overridable updateParameterList(list, arg)
	{
		return new ParameterList(mapList(list, arg));
	}

	// Document

	overridable override visitDocument(document, arg)
	{
		document.useDirectives = updateNodeList(document.useDirectives, arg);
		document.members = updateNodeList(document.members, arg);
		document.statements = updateNodeList(document.statements, arg);
		return document;
	}

	overridable override visitUseAliasDirective(directive, arg)
	{
		return directive;
	}

	overridable override visitUseFileDirective(directive, arg)
	{
		return directive;
	}

	overridable override visitUseNamespaceDirective(directive, arg)
	{
		return directive;
	}

	// Declarations

	overridable override visitClassConstantDeclaration(decl, arg)
	{
		decl.annotations = updateNodeList(decl.annotations, arg);
		decl.constants = updateNodeList(decl.constants, arg);
		return decl;
	}

	overridable override visitClassDeclaration(decl, arg)
	{
		decl.annotations = updateNodeList(decl.annotations, arg);
		if decl.baseType is TypeName:
			decl.baseType = visitTypeName(decl.baseType, arg);
		decl.members = updateNodeList(decl.members, arg);
		return decl;
	}

	overridable override visitConstructorDeclaration(decl, arg)
	{
		decl.annotations = updateNodeList(decl.annotations, arg);
		decl.parameters = updateParameterList(decl.parameters, arg);
		decl.body = decl.body?.accept(this, arg);
		return decl;
	}

	overridable override visitThisParameter(param, arg)
	{
		param.defaultValue = param.defaultValue.accept(this, arg);
		return param;
	}

	overridable override visitEnumDeclaration(decl, arg)
	{
		decl.annotations = updateNodeList(decl.annotations, arg);
		decl.members = updateNodeList(decl.members, arg);
		return decl;
	}

	overridable override visitEnumMember(decl, arg)
	{
		decl.annotations = updateNodeList(decl.annotations, arg);
		decl.value = decl.value?.accept(this, arg);
		return decl;
	}

	overridable override visitExternBody(node, arg)
	{
		node.locals = node.locals?.accept(this, arg);
		return node;
	}

	overridable override visitFieldDeclaration(decl, arg)
	{
		decl.annotations = updateNodeList(decl.annotations, arg);
		decl.fields = updateNodeList(decl.fields, arg);
		return decl;
	}

	overridable override visitGlobalConstantDeclaration(decl, arg)
	{
		decl.annotations = updateNodeList(decl.annotations, arg);
		decl.constants = updateNodeList(decl.constants, arg);
		return decl;
	}

	overridable override visitGlobalFunctionDeclaration(decl, arg)
	{
		decl.annotations = updateNodeList(decl.annotations, arg);
		decl.parameters = updateParameterList(decl.parameters, arg);
		decl.body = decl.body.accept(this, arg);
		return decl;
	}

	overridable override visitGlobalVariableDeclaration(decl, arg)
	{
		decl.declaration = decl.declaration.accept(this, arg);
		return decl;
	}

	overridable override visitPropertyDeclaration(decl, arg)
	{
		decl.annotations = updateNodeList(decl.annotations, arg);
		decl.body = decl.body?.accept(this, arg);
		return decl;
	}

	overridable override visitIndexerDeclaration(decl, arg)
	{
		decl.annotations = updateNodeList(decl.annotations, arg);
		decl.parameters = updateParameterList(decl.parameters, arg);
		decl.body = decl.body?.accept(this, arg);
		return decl;
	}

	overridable override visitAnnotation(annotation, arg)
	{
		annotation.type = visitTypeName(annotation.type, arg);
		annotation.positionalArguments = updateArgumentList(annotation.positionalArguments, arg);
		annotation.namedArguments = updateArgumentList(annotation.namedArguments, arg);
		return annotation;
	}

	overridable override visitMethodDeclaration(decl, arg)
	{
		decl.annotations = updateNodeList(decl.annotations, arg);
		decl.parameters = updateParameterList(decl.parameters, arg);
		decl.body = decl.body?.accept(this, arg);
		return decl;
	}

	overridable override visitParameter(param, arg)
	{
		param.defaultValue = param.defaultValue?.accept(this, arg);
		return param;
	}

	overridable override visitInvocatorDeclaration(decl, arg)
	{
		decl.annotations = updateNodeList(decl.annotations, arg);
		decl.parameters = updateParameterList(decl.parameters, arg);
		decl.body = decl.body?.accept(this, arg);
		return decl;
	}

	overridable override visitIteratorDeclaration(decl, arg)
	{
		decl.annotations = updateNodeList(decl.annotations, arg);
		decl.body = decl.body.accept(this, arg);
		return decl;
	}

	overridable override visitNamespaceDeclaration(decl, arg)
	{
		decl.members = updateNodeList(decl.members, arg);
		return decl;
	}

	overridable override visitOperatorDeclaration(decl, arg)
	{
		decl.annotations = updateNodeList(decl.annotations, arg);
		decl.parameters = updateParameterList(decl.parameters, arg);
		decl.body = decl.body.accept(this, arg);
		return decl;
	}

	overridable override visitStaticConstructorDeclaration(decl, arg)
	{
		decl.annotations = updateNodeList(decl.annotations, arg);
		decl.body = decl.body.accept(this, arg);
		return decl;
	}

	overridable override visitVariableDeclarator(decl, arg)
	{
		decl.initializer = decl.initializer?.accept(this, arg);
		return decl;
	}

	// Statements

	overridable override visitBlock(block, arg)
	{
		block.statements = updateNodeList(block.statements, arg);
		return block;
	}

	overridable override visitBaseConstructorCall(stmt, arg)
	{
		stmt.statements = updateArgumentList(stmt.arguments, arg);
		return stmt;
	}

	overridable override visitBreakStatement(stmt, arg)
	{
		return stmt;
	}

	overridable override visitCompoundAssignment(stmt, arg)
	{
		stmt.left = stmt.left.accept(this, arg);
		stmt.right = stmt.right.accept(this, arg);
		return stmt;
	}

	overridable override visitDoWhileStatement(stmt, arg)
	{
		stmt.body = stmt.body.accept(this, arg);
		stmt.condition = stmt.condition?.accept(this, arg);
		return stmt;
	}

	overridable override visitEmptyStatement(stmt, arg)
	{
		return stmt;
	}

	overridable override visitExpressionStatement(stmt, arg)
	{
		stmt.expression = stmt.expression.accept(this, arg);
		return stmt;
	}

	overridable override visitForStatement(stmt, arg)
	{
		stmt.expression = stmt.expression.accept(this, arg);
		stmt.body = stmt.body.accept(this, arg);
		stmt.elseClause = stmt.elseClause?.accept(this, arg);
		return stmt;
	}

	overridable override visitIfStatement(stmt, arg)
	{
		stmt.condition = stmt.condition.accept(this, arg);
		stmt.consequence = stmt.consequence.accept(this, arg);
		stmt.alternative = stmt.alternative?.accept(this, arg);
		return stmt;
	}

	overridable override visitLocalConstantDeclaration(decl, arg)
	{
		decl.constants = updateNodeList(decl.constants, arg);
		return decl;
	}

	overridable override visitLocalFunctionDeclaration(decl, arg)
	{
		decl.parameters = updateParameterList(decl.parameters, arg);
		decl.body = decl.body.accept(this, arg);
		return decl;
	}

	overridable override visitLocalVariableDeclaration(decl, arg)
	{
		decl.variables = updateNodeList(decl.variables, arg);
		return decl;
	}

	overridable override visitNextStatement(stmt, arg)
	{
		return stmt;
	}

	overridable override visitParallelAssignment(stmt, arg)
	{
		stmt.targets = updateNodeList(stmt.targets, arg);
		stmt.values = updateNodeList(stmt.values, arg);
		return stmt;
	}

	overridable override visitParallelLocalVariableDeclaration(decl, arg)
	{
		decl.value = decl.value.accept(this, arg);
		return decl;
	}

	overridable override visitReturnStatement(stmt, arg)
	{
		stmt.returnValues = updateNodeList(stmt.returnValues, arg);
		return stmt;
	}

	overridable override visitThisConstructorCall(stmt, arg)
	{
		stmt.arguments = updateNodeList(stmt.arguments, arg);
		return stmt;
	}

	overridable override visitThrowStatement(stmt, arg)
	{
		stmt.expression = stmt.expression?.accept(this, arg);
		return stmt;
	}

	overridable override visitTryStatement(stmt, arg)
	{
		stmt.tryClause = visitTryClause(stmt.tryClause, arg);
		stmt.catchClauses = updateNodeList(stmt.catchClauses, arg);
		if stmt.finallyClause is not null:
			stmt.finallyClause = visitFinallyClause(stmt.finallyClause, arg);
		return stmt;
	}

	overridable override visitTryClause(clause, arg)
	{
		clause.statements = updateNodeList(clause.statements, arg);
		return clause;
	}

	overridable override visitGenericCatchClause(clause, arg)
	{
		clause.statements = updateNodeList(clause.statements, arg);
		return clause;
	}

	overridable override visitSpecificCatchClause(clause, arg)
	{
		clause.caughtType = visitTypeName(clause.caughtType, arg);
		clause.statements = updateNodeList(clause.statements, arg);
		return clause;
	}

	overridable override visitFinallyClause(clause, arg)
	{
		clause.statements = updateNodeList(clause.statements, arg);
		return clause;
	}

	overridable override visitWhileStatement(stmt, arg)
	{
		stmt.condition = stmt.condition.accept(this, arg);
		stmt.body = stmt.body.accept(this, arg);
		return stmt;
	}

	overridable override visitWithStatement(stmt, arg)
	{
		stmt.expression = stmt.expression.accept(this, arg);
		stmt.body = stmt.body.accept(this, arg);
		return stmt;
	}

	overridable override visitYieldStatement(stmt, arg)
	{
		stmt.returnValues = updateNodeList(stmt.returnValues, arg);
		return stmt;
	}

	// Expressions

	overridable override visitAssignmentExpression(expr, arg)
	{
		expr.target = expr.target.accept(this, arg);
		expr.value = expr.value.accept(this, arg);
		return expr;
	}

	overridable override visitBaseAccess(expr, arg)
	{
		return expr;
	}

	overridable override visitBinaryExpression(expr, arg)
	{
		expr.left = expr.left.accept(this, arg);
		expr.right = expr.right.accept(this, arg);
		return expr;
	}

	overridable override visitNullLiteral(expr, arg)
	{
		return expr;
	}

	overridable override visitBooleanLiteral(expr, arg)
	{
		return expr;
	}

	overridable override visitIntegerLiteral(expr, arg)
	{
		return expr;
	}

	overridable override visitRealLiteral(expr, arg)
	{
		return expr;
	}

	overridable override visitStringLiteral(expr, arg)
	{
		return expr;
	}

	overridable override visitCharLiteral(expr, arg)
	{
		return expr;
	}

	overridable override visitConditionalAndExpression(expr, arg)
	{
		expr.left = expr.left.accept(this, arg);
		expr.right = expr.right.accept(this, arg);
		return expr;
	}

	overridable override visitConditionalExpression(expr, arg)
	{
		expr.condition = expr.condition.accept(this, arg);
		expr.truePart = expr.truePart.accept(this, arg);
		expr.falsePart = expr.falsePart.accept(this, arg);
		return expr;
	}

	overridable override visitConditionalOrExpression(expr, arg)
	{
		expr.left = expr.left.accept(this, arg);
		expr.right = expr.right.accept(this, arg);
		return expr;
	}

	overridable override visitConditionalXorExpression(expr, arg)
	{
		expr.left = expr.left.accept(this, arg);
		expr.right = expr.right.accept(this, arg);
		return expr;
	}

	overridable override visitGetArgumentCountExpression(expr, arg)
	{
		return expr;
	}

	overridable override visitGlobalAccess(expr, arg)
	{
		return expr;
	}

	overridable override visitHashCreationExpression(expr, arg)
	{
		expr.members = updateNodeList(expr.members, arg);
		return expr;
	}

	overridable override visitHashMember(member, arg)
	{
		member.key = member.key.accept(this, arg);
		member.value = member.value.accept(this, arg);
		return member;
	}

	overridable override visitIndexerAccess(expr, arg)
	{
		expr.inner = expr.inner.accept(this, arg);
		expr.arguments = updateArgumentList(expr.arguments, arg);
		return expr;
	}

	overridable override visitInvocationExpression(expr, arg)
	{
		expr.inner = expr.inner.accept(this, arg);
		expr.arguments = updateArgumentList(expr.arguments, arg);
		return expr;
	}

	overridable override visitIteratorAccess(expr, arg)
	{
		expr.inner = expr.inner.accept(this, arg);
		return expr;
	}

	overridable override visitLambdaMemberExpression(expr, arg)
	{
		expr.members = updateNodeList(expr.members, arg);
		return expr;
	}

	overridable override visitLambdaOperatorExpression(expr, arg)
	{
		return expr;
	}

	overridable override visitListCreationExpression(expr, arg)
	{
		expr.values = updateNodeList(expr.values, arg);
		return expr;
	}

	overridable override visitMemberAccess(expr, arg)
	{
		expr.inner = expr.inner.accept(this, arg);
		return expr;
	}

	overridable override visitNamedConstantExpression(expr, arg)
	{
		return expr;
	}

	overridable override visitNullCoalescingExpression(expr, arg)
	{
		expr.left = expr.left.accept(this, arg);
		expr.right = expr.right.accept(this, arg);
		return expr;
	}

	overridable override visitNullOrExpression(expr, arg)
	{
		expr.left = expr.left.accept(this, arg);
		expr.right = expr.right.accept(this, arg);
		return expr;
	}

	overridable override visitObjectCreationExpression(expr, arg)
	{
		expr.type = visitTypeName(expr.type, arg);
		expr.arguments = updateArgumentList(expr.arguments, arg);
		expr.initializer = expr.initializer?.accept(this, arg);
		return expr;
	}

	overridable override visitObjectInitializer(initializer, arg)
	{
		initializer.members = updateNodeList(initializer.members, arg);
		return initializer;
	}

	overridable override visitMemberInitializer(initializer, arg)
	{
		initializer.expression = initializer.expression.accept(this, arg);
		return initializer;
	}

	overridable override visitCollectionInitializer(initializer, arg)
	{
		initializer.elements = updateNodeList(initializer.elements, arg);
		return initializer;
	}

	overridable override visitElementInitializer(initializer, arg)
	{
		initializer.arguments = updateArgumentList(initializer.arguments, arg);
		return initializer;
	}

	overridable override visitParenthesizedExpression(expr, arg)
	{
		expr.inner = expr.inner.accept(this, arg);
		return expr;
	}

	overridable override visitRangeExpression(expr, arg)
	{
		expr.low = expr.low.accept(this, arg);
		expr.high = expr.high.accept(this, arg);
		expr.step = expr.step?.accept(this, arg);
		return expr;
	}

	overridable override visitRefExpression(expr, arg)
	{
		expr.inner = expr.inner.accept(this, arg);
		return expr;
	}

	overridable override visitSafeAccess(expr, arg)
	{
		expr.inner = expr.inner.accept(this, arg);
		expr.chain = updateNodeList(expr.chain, arg);
		return expr;
	}

	overridable override visitSafeIndexerAccess(node, arg)
	{
		node.arguments = updateArgumentList(node.arguments, arg);
		return node;
	}

	overridable override visitSafeInvocation(node, arg)
	{
		node.arguments = updateArgumentList(node.arguments, arg);
		return node;
	}

	overridable override visitSafeIteratorAccess(node, arg)
	{
		return node;
	}

	overridable override visitSafeMemberAccess(node, arg)
	{
		return node;
	}

	overridable override visitSimpleLambdaExpression(expr, arg)
	{
		expr.parameters = updateParameterList(expr.parameters, arg);
		expr.body = expr.body.accept(this, arg);
		return expr;
	}

	overridable override visitSimpleName(expr, arg)
	{
		return expr;
	}

	overridable override visitThisAccess(expr, arg)
	{
		return expr;
	}

	overridable override visitTypeOfExpression(expr, arg)
	{
		expr.inner = expr.inner.accept(this, arg);
		return expr;
	}

	overridable override visitTypeTestExpression(expr, arg)
	{
		expr.expression = expr.expression.accept(this, arg);
		if expr.type is not null:
			expr.type = visitTypeName(expr.type, arg);
		return expr;
	}

	overridable override visitUnaryExpression(expr, arg)
	{
		expr.inner = expr.inner.accept(this, arg);
		return expr;
	}

	overridable override visitUseInExpression(expr, arg)
	{
		expr.variables = updateNodeList(expr.variables, arg);
		expr.expression = expr.expression.accept(this, arg);
		return expr;
	}

	// Type names

	overridable override visitTypeName(typeName, arg)
	{
		return typeName;
	}

}
