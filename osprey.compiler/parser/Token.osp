use namespace aves;
use namespace osprey.compiler.syntax;

namespace osprey.compiler.parser;

/// Summary: Represents a single token in a source file.
public inheritable Token is Syntax
{
	public new(location, type)
	{
		new this(location, type, null);
	}
	public new(location, type, value)
	{
		new base(location);

		if type is not TokenType:
			throw new TypeError();

		_type = type;
		_value = value;
	}

	private _type;
	/// Summary: Gets the type of the token.
	public get type = _type;

	private _value;
	/// Summary: Gets a string representation of the token.
	public get value
	{
		if _value is null:
			_value = location.getText();
		return _value;
	}

	private _documentation;
	/// Summary: Gets the documentation comment associated with this token, as a
	///          {Token} with type {TokenType.comment}, or null if there is none.
	public get documentation = _documentation;
	/// Summary: Sets the documentation comment associated with this token, as a
	///          {Token} with type {TokenType.comment}, or null if there is none.
	public set documentation { _documentation = value; }

	public match(type)
	{
		if type == TokenType.invalid:
			return _type == TokenType.invalid;
		else if type & TokenType.valueMask == TokenType.none:
			return _type & type == type;
		else:
			return _type == type;
	}

	public match(t1, t2)
	{
		return match(t1) or match(t2);
	}

	public match(t1, t2, t3)
	{
		return match(t1) or match(t2) or match(t3);
	}

	public matchAny(types)
	{
		return types.any(match);
	}

	overridable override toString()
	{
		if type == TokenType.eof:
			return "end of file";

		var cat = type & TokenType.categoryMask;
		if cat == TokenType.keyword:
			return "keyword '{0}'".format([value]);

		return "'{0}' ({1})".format([value, type]);
	}
}

/// Summary: Represents a single literal value token, such as a string literal, numeric
///          literal, or `true`, `false` or `null`.
public inheritable LiteralToken is Token
{
	public new(location, type, literalValue)
	{
		new base(location, type, null);

		this._literalValue = literalValue;
	}

	private _literalValue;
	/// Summary: Gets the value represented by the literal token.
	public get literalValue = _literalValue;

	overridable override toString()
	{
		return "literal '{0}' ({1})".format([value, type]);
	}
}

public class Identifier is Token
{
	public new(location, identifier)
	{
		new base(location, TokenType.identifier);

		this._identifier = identifier;
	}

	private _identifier;
	/// Summary: Gets the identifier represented by the {Identifier}. This may differ
	///          from the tokenâ€™s {value} if the identifier has been normalized.
	public get identifier = _identifier;

	override toString()
	{
		return "identifier '{0}'".format([value]);
	}
}