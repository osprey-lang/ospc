use aves;
use osprey.compiler.parser;

namespace osprey.compiler.syntax.wrapped;

public inheritable WrappedBlock is WrappedStatement
{
	public new(wrappedNode, statements)
	{
		new base(wrappedNode);

		this.statements = claimAll(statements);
	}

	/// Summary: A {NodeList} containing the statements of the block.
	public statements;

	overridable override accept(visitor, arg)
	{
		return visitor.visitBlock(this, arg);
	}
}

public class WrappedEmptyStatement is WrappedStatement
{
	public new(wrappedNode)
	{
		new base(wrappedNode);
	}

	override accept(visitor, arg)
	{
		return visitor.visitEmptyStatement(this, arg);
	}
}

public class WrappedExpressionStatement is WrappedStatement
{
	public new(wrappedNode, expression)
	{
		new base(wrappedNode);

		this.expression = claim(expression);
	}

	/// Summary: The {WrappedExpression} contained within the statement.
	public expression;

	override accept(visitor, arg)
	{
		return visitor.visitExpressionStatement(this, arg);
	}
}

public class WrappedIfStatement is WrappedStatement
{
	public new(wrappedNode, condition, consequence, alternative)
	{
		new base(wrappedNode);

		this.condition   = claim(condition);
		this.consequence = claim(consequence);
		this.alternative = claim(alternative);
	}

	/// Summary: The {WrappedExpression} that makes up the condition of the if statement.
	public condition;

	/// Summary: A {WrappedStatement} that contains the body of the if statement.
	public consequence;

	/// Summary: A {WrappedStatement} that contains the else clause of the if statement,
	///          or null if it has none.
	public alternative;

	override accept(visitor, arg)
	{
		return visitor.visitIfStatement(this, arg);
	}
}

public abstract class WrappedIterationStatement is WrappedStatement
{
	public new(wrappedNode, body)
	{
		new base(wrappedNode);

		this.body = claim(body);
	}

	/// Summary: Gets the label attached to the iteration statement, as an {Identifier}
	///          token, or null if the loop is unlabelled.
	public get label = wrappedNode.label;

	/// Summary: A {WrappedStatement} that contains the body of the iteration statement.
	public body;

	abstract override accept(visitor, arg);
}

public class WrappedForStatement is WrappedIterationStatement
{
	public new(wrappedNode, expression, body, elseClause)
	{
		new base(wrappedNode, body);

		this.expression = claim(expression);
		this.elseClause = claim(elseClause);
	}

	/// Summary: Gets a collection of the variable names declared by this statement,
	///          as a {SyntaxList} of {Identifier} tokens.
	public get variables = wrappedNode.variables;

	/// Summary: The {WrappedExpression} that is evaluated to produce the collection
	///          iterated over by the for statement.
	public expression;

	/// Summary: A {WrappedStatement} containing the else clause of the for statement,
	///          or null if it has none.
	public elseClause;

	override accept(visitor, arg)
	{
		return visitor.visitForStatement(this, arg);
	}
}

public class WrappedWhileStatement is WrappedIterationStatement
{
	public new(wrappedNode, condition, body)
	{
		new base(wrappedNode, body);

		this.condition = claim(condition);
	}

	/// Summary: The {WrappedExpression} that is the condition of the while statement.
	public condition;

	override accept(visitor, arg)
	{
		return visitor.visitWhileStatement(this, arg);
	}
}

public class WrappedDoWhileStatement is WrappedIterationStatement
{
	public new(wrappedNode, body, condition)
	{
		new base(wrappedNode, body);

		this.condition = claim(condition);
	}

	/// Summary: The {WrappedExpression} that is the condition of the do-while statement.
	public condition;

	override accept(visitor, arg)
	{
		return visitor.visitDoWhileStatement(this, arg);
	}
}

public class WrappedReturnStatement is WrappedStatement
{
	public new(wrappedNode, returnValues)
	{
		new base(wrappedNode);

		this.returnValues = claimAll(returnValues);
	}

	/// Summary: A {NodeList} of the return values of this statement.
	public returnValues;

	override accept(visitor, arg)
	{
		return visitor.visitReturnStatement(this, arg);
	}
}

public class WrappedYieldStatement is WrappedStatement
{
	public new(wrappedNode, returnValues)
	{
		new base(wrappedNode);

		this.returnValues = claimAll(returnValues);
	}

	/// Summary: A {NodeList} of the return values of this statement.
	public returnValues;

	override accept(visitor, arg)
	{
		return visitor.visitYieldStatement(this, arg);
	}
}

public class WrappedNextStatement is WrappedStatement
{
	public new(wrappedNode)
	{
		new base(wrappedNode);
	}

	/// Summary: Gets the name of the loop label that this statement refers to,
	///          as an {Identifier} token, or null if the statement is unlabelled.
	public get label = wrappedNode.label;

	override accept(visitor, arg)
	{
		return visitor.visitNextStatement(this, arg);
	}
}

public class WrappedBreakStatement is WrappedStatement
{
	public new(wrappedNode)
	{
		new base(wrappedNode);
	}

	/// Summary: Gets the name of the loop label that this statement refers to,
	///          as an {Identifier} token, or null if the statement is unlabelled.
	public get label = wrappedNode.label;

	override accept(visitor, arg)
	{
		return visitor.visitBreakStatement(this, arg);
	}
}

public class WrappedThrowStatement is WrappedStatement
{
	public new(wrappedNode, expression)
	{
		new base(wrappedNode);

		this.expression = claim(expression);
	}

	/// Summary: Gets the expression of the throw statement, or null if it has none.
	public expression;

	override accept(visitor, arg)
	{
		return visitor.visitThrowStatement(this, arg);
	}
}

public class WrappedTryStatement is WrappedStatement
{
	public new(wrappedNode, tryClause, catchClauses, finallyClause)
	{
		new base(wrappedNode);

		this.tryClause     = claim(tryClause);
		this.catchClauses  = claimAll(catchClauses);
		this.finallyClause = claim(finallyClause);
	}

	/// Summary: Gets the {WrappedTryClause} of the try statement.
	public tryClause;

	/// Summary: Gets a {WrappedNodeList} containing the catch clauses of the try statement.
	public catchClauses;

	/// Summary: Gets the {WrappedFinallyClause} of the try statement, or null if it has none.
	public finallyClause;

	override accept(visitor, arg)
	{
		return visitor.visitTryStatement(this, arg);
	}
}

public class WrappedTryClause is WrappedBlock
{
	public new(wrappedNode, statements)
	{
		new base(wrappedNode, statements);
	}

	override accept(visitor, arg)
	{
		return visitor.visitTryClause(this, arg);
	}
}

public inheritable WrappedGenericCatchClause is WrappedBlock
{
	public new(wrappedNode, statements)
	{
		new base(wrappedNode, statements);
	}

	overridable override accept(visitor, arg)
	{
		return visitor.visitGenericCatchClause(this, arg);
	}
}

public class WrappedSpecificCatchClause is WrappedGenericCatchClause
{
	public new(wrappedNode, caughtType, statements)
	{
		new base(wrappedNode, statements);

		this.caughtType = claim(caughtType);
	}

	/// Summary: A {WrappedTypeName} that represents the type caught by the catch clause.
	public caughtType;

	/// Summary: Gets an {Identifier} token containing the name of the catch variable,
	///          or null if the catch clause specifies no variable name.
	public get variable = wrappedNode.variable;

	override accept(visitor, arg)
	{
		return visitor.visitSpecificCatchClause(this, arg);
	}
}

public class WrappedFinallyClause is WrappedBlock
{
	public new(wrappedNode, statements)
	{
		new base(wrappedNode, statements);
	}

	override accept(visitor, arg)
	{
		return visitor.visitFinallyClause(this, arg);
	}
}

public class WrappedWithStatement is WrappedStatement
{
	public new(wrappedNode, expression, body)
	{
		new base(wrappedNode);

		this.expression = claim(expression);
		this.body       = claim(body);
	}

	/// Summary: Gets the name of the variable declared by the statement,
	///          as an {Identifier} token.
	public get variable = wrappedNode.variable;

	/// Summary: The initializer {WrappedExpression} of the with statement.
	public expression;

	/// Summary: The {WrappedStatement} that is the body of the with statement.
	public body;

	override accept(visitor, arg)
	{
		return visitor.visitWithStatement(this, arg);
	}
}

public class WrappedCompoundAssignment is WrappedStatement
{
	public new(wrappedNode, left, right)
	{
		new base(wrappedNode);

		this.left  = claim(left);
		this.right = claim(right);
	}

	/// Summary: The left-hand side {WrappedExpression} of the assignment.
	public left;

	/// Summary: Gets the {BinaryOperator} that the compound assignment uses.
	public get op = wrappedNode.op;

	/// Summary: The right-hand side {WrappedExpression} of the assignment.
	public right;

	override accept(visitor, arg)
	{
		return visitor.visitCompoundAssignment(this, arg);
	}
}

public class WrappedParallelAssignment is WrappedStatement
{
	public new(wrappedNode, targets, values)
	{
		new base(wrappedNode);

		this.targets = claimAll(targets);
		this.values  = claimAll(values);
	}

	/// Summary: A {NodeList} containing the target {WrappedExpression}s of the assignment.
	public targets;

	/// Summary: A {NodeList} containing the value {WrappedExpression}s of the assignment.
	public values;

	override accept(visitor, arg)
	{
		return visitor.visitParallelAssignment(this, arg);
	}
}

public class WrappedBaseConstructorCall is WrappedStatement
{
	public new(wrappedNode, arguments)
	{
		new base(wrappedNode);

		this.arguments = claimAll(arguments);
	}

	/// Summary: A {WrappedArgumentList} with the arguments to the base constructor.
	public arguments;

	override accept(visitor, arg)
	{
		return visitor.visitBaseConstructorCall(this, arg);
	}
}

public class WrappedThisConstructorCall is WrappedStatement
{
	public new(wrappedNode, arguments)
	{
		new base(wrappedNode);

		this.arguments = claimAll(arguments);
	}

	/// Summary: A {WrappedArgumentList} with the arguments to the constructor on the own type.
	public arguments;

	override accept(visitor, arg)
	{
		return visitor.visitThisConstructorCall(this, arg);
	}
}

public abstract class WrappedLocalDeclaration is WrappedStatement
{
	public new(wrappedNode)
	{
		new base(wrappedNode);
	}

	abstract override accept(visitor, arg);
}

public class WrappedSimpleLocalVariableDeclaration is WrappedLocalDeclaration
{
	public new(wrappedNode, variables)
	{
		new base(wrappedNode);

		this.variables = claimAll(variables);
	}

	/// Summary: A {NodeList} containing the {WrappedVariableDeclarator}s of this
	///          local variable declaration.
	public variables;

	override accept(visitor, arg)
	{
		return visitor.visitLocalVariableDeclaration(this, arg);
	}
}

public class WrappedParallelLocalVariableDeclaration is WrappedLocalDeclaration
{
	public new(wrappedNode, value)
	{
		new base(wrappedNode);

		this.value = claim(value);
	}

	/// Summary: Gets a {SyntaxList} containing the {Identifier}s corresponding
	///          to the names of the declared variables.
	public get names = wrappedNode.names;

	/// Summary: Gets the initializer {Expression} of the declaration.
	public value;

	override accept(visitor, arg)
	{
		return visitor.visitParallelLocalVariableDeclaration(this, arg);
	}
}

public class WrappedLocalConstantDeclaration is WrappedLocalDeclaration
{
	public new(wrappedNode, constants)
	{
		new base(wrappedNode);

		this.constants = claimAll(constants);
	}

	/// Summary: A {NodeList} containing the {WrappedVariableDeclarator}s of this
	///          local constant declaration.
	public constants;

	override accept(visitor, arg)
	{
		return visitor.visitLocalConstantDeclaration(this, arg);
	}
}

public class WrappedLocalFunctionDeclaration is WrappedLocalDeclaration
{
	public new(wrappedNode, parameters, body)
	{
		new base(wrappedNode);

		this.parameters = claimAll(parameters);
		this.body       = claim(body);
	}

	/// Summary: Gets an {Identifier} corresponding to the name of the function.
	public get name = wrappedNode.name;

	/// Summary: Gets a {WrappedParameterList} containing the parameters of the function.
	public parameters;

	/// Summary: Gets a {WrappedBlock} containing the body of the function.
	public body;

	override accept(visitor, arg)
	{
		return visitor.visitLocalFunctionDeclaration(this, arg);
	}
}
