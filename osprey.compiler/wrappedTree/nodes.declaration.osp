use aves;
use osprey.compiler.parser;

namespace osprey.compiler.syntax.wrapped;

public class WrappedNamespaceDeclaration is WrappedNode
{
	public new(wrappedNode, members)
	{
		new base(wrappedNode);

		this.members = claimAll(members);
	}

	/// Summary: Gets a {QualifiedName} corresponding to the declared name
	///          of the namespace.
	public get name = wrappedNode.name;

	/// Summary: A {NodeList} containing the members of this namespace declaration.
	public members;

	override accept(visitor, arg)
	{
		return visitor.visitNamespaceDeclaration(this, arg);
	}
}

public class WrappedGlobalConstantDeclaration is WrappedNode
{
	public new(wrappedNode, annotations, constants)
	{
		new base(wrappedNode);

		this.annotations = claimAll(annotations);
		this.constants   = claimAll(constants);
	}

	/// Summary: The annotations associated with the global constant,
	///          as a {NodeList} of {WrappedAnnotation} instances.
	public annotations;

	/// Summary: Gets the declared {Accessibility} of the global constants.
	public get accessibility = wrappedNode.accessibility;

	/// Summary: A {NodeList} containing {WrappedVariableDeclarator}s that represent
	///          the constants declared in this declaration.
	public constants;

	override accept(visitor, arg)
	{
		return visitor.visitGlobalConstantDeclaration(this, arg);
	}
}

public class WrappedGlobalFunctionDeclaration is WrappedNode
{
	public new(wrappedNode, annotations, parameters, body)
	{
		new base(wrappedNode);

		this.annotations = claimAll(annotations);
		this.parameters  = claimAll(parameters);
		this.body        = claim(body);
	}

	/// Summary: The annotations associated with the global function,
	///          as a {NodeList} of {WrappedAnnotation} instances.
	public annotations;

	/// Summary: Gets the declared {Accessibility} of the global constants.
	public get accessibility = wrappedNode.accessibility;

	/// Summary: Gets an {Identifier} corresponding to the name of the global function.
	public get name = wrappedNode.name;

	/// Summary: A {WrappedParameterList} containing the function’s parameters.
	public parameters;

	/// Summary: A {WrappedNode} containing the function’s body. This is usually
	///          a {WrappedBlock}, but may be a {WrappedExternBody} if non-standard
	///          extensions are enabled.
	public body;

	override accept(visitor, arg)
	{
		return visitor.visitGlobalFunctionDeclaration(this, arg);
	}
}

public abstract class WrappedTypeDeclaration is WrappedNode
{
	public new(wrappedNode, annotations)
	{
		new base(wrappedNode);

		this.annotations = claimAll(annotations);
	}

	/// Summary: The annotations associated with the type, as a
	///          {NodeList} of {WrappedAnnotation} instances.
	public annotations;

	/// Summary: Gets the declared {Accessibility} of the type.
	public get accessibility = wrappedNode.accessibility;

	/// Summary: Gets an {Identifier} corresponding to the name of the type declaration.
	public get name = wrappedNode.name;

	abstract override accept(visitor, arg);
}

public class WrappedClassDeclaration is WrappedTypeDeclaration
{
	public new(wrappedNode, annotations, baseType, members)
	{
		new base(wrappedNode, annotations);

		this.baseType = claim(baseType);
		this.members  = claimAll(members);
	}

	/// Summary: Determines whether the class declaration is marked static.
	public get isStatic = wrappedNode.isStatic;

	/// Summary: Determines whether the class declaration is marked abstract.
	public get isAbstract = wrappedNode.isAbstract;

	/// Summary: Determines whether the class declaration is marked inheritable.
	public get isInheritable = wrappedNode.isInheritable;

	/// Summary: The base type of the class. This is either a {WrappedTypeName},
	///          or the same reference as {ClassDeclaration.primitive}, or null.
	public baseType;

	/// Summary: A {NodeList} containing the {WrappedClassMember}s of the class declaration.
	public members;

	/// Summary: Gets a string {LiteralToken} containing the type initializer name,
	///          if specified, or null otherwise. This is a non-standard extension.
	public get typeInitializer = wrappedNode.typeInitializer;

	override accept(visitor, arg)
	{
		return visitor.visitClassDeclaration(this, arg);
	}
}

public abstract class WrappedClassMember is WrappedNode
{
	public new(wrappedNode, annotations)
	{
		new base(wrappedNode);

		this.annotations = claimAll(annotations);
	}

	/// Summary: The annotations associated with the member, as a
	///          {NodeList} of {WrappedAnnotation} instances.
	public annotations;

	/// Summary: Gets the declared {Accessibility} of the member.
	public get accessibility = wrappedNode.accessibility;

	/// Summary: Determines whether the member is declared static.
	public get isStatic = wrappedNode.isStatic;

	/// Summary: Gets an {Identifier} corresponding to the name of the member.
	///          If the member is unnamed, such as a constructor or iterator,
	///          or declares multiple members, such as a field declaration,
	///          this property returns null.
	public get name = wrappedNode.name;

	abstract override accept(visitor, arg);
}

public class WrappedConstructorDeclaration is WrappedClassMember
{
	public new(wrappedNode, annotations, parameters, body)
	{
		new base(wrappedNode, annotations);

		this.parameters = claimAll(parameters);
		this.body       = claim(body);
	}

	/// Summary: A {WrappedParameterList} containing the constructor’s parameters.
	public parameters;

	/// Summary: A {WrappedBlock} containing the body of the constructor, or null
	///          if the constructor lacks a body.
	public body;

	override accept(visitor, arg)
	{
		return visitor.visitConstructorDeclaration(this, arg);
	}
}

public class WrappedStaticConstructorDeclaration is WrappedClassMember
{
	public new(wrappedNode, annotations, body)
	{
		new base(wrappedNode, annotations);

		this.body = claim(body);
	}

	/// Summary: A {WrappedBlock} containing the body of the static constructor.
	public body;

	override accept(visitor, arg)
	{
		return visitor.visitStaticConstructorDeclaration(this, arg);
	}
}

public class WrappedFieldDeclaration is WrappedClassMember
{
	public new(wrappedNode, annotations, fields)
	{
		new base(wrappedNode, annotations);

		this.fields = claimAll(fields);
	}

	/// Summary: A {NodeList} containing the {WrappedVariableDeclarator}s of this
	///          field declaration.
	public fields;

	override accept(visitor, arg)
	{
		return visitor.visitFieldDeclaration(this, arg);
	}
}

public inheritable WrappedPropertyDeclaration is WrappedClassMember
{
	public new(wrappedNode, annotations, body)
	{
		new base(wrappedNode, annotations);

		this.body = claim(body);
	}

	/// Summary: Determines whether the property accessor is abstract.
	public get isAbstract = wrappedNode.isAbstract;

	/// Summary: Determines whether the property accessor is an override.
	public get isOverride = wrappedNode.isOverride;

	/// Summary: Determines whether the property accessor is overridable.
	public get isOverridable = wrappedNode.isOverridable;

	/// Summary: Determines whether the property accessor is a setter.
	public get isSetter = wrappedNode.isSetter;

	/// Summary: Determines whether the property accessor is a getter.
	public get isGetter = not wrappedNode.isSetter;

	/// Summary: A {WrappedBlock} or {WrappedExpression} that contains
	///          the body of the property accessor.
	public body;

	overridable override accept(visitor, arg)
	{
		return visitor.visitPropertyDeclaration(this, arg);
	}
}

public class WrappedIndexerDeclaration is WrappedPropertyDeclaration
{
	public new(wrappedNode, annotations, parameters, body)
	{
		new base(wrappedNode, annotations, body);

		this.parameters = claimAll(parameters);
	}

	/// Summary: A {WrappedParameterList} containing the indexer accessor’s parameters.
	public parameters;

	override accept(visitor, arg)
	{
		return visitor.visitIndexerDeclaration(this, arg);
	}
}

public inheritable WrappedMethodDeclaration is WrappedClassMember
{
	public new(wrappedNode, annotations, parameters, body)
	{
		new base(wrappedNode, annotations);

		this.parameters = claimAll(parameters);
		this.body       = claim(body);
	}

	/// Summary: Determines whether the method is abstract.
	public get isAbstract = wrappedNode.isAbstract;

	/// Summary: Determines whether the method is an override.
	public get isOverride = wrappedNode.isOverride;

	/// Summary: Determines whether the method is overridable.
	public get isOverridable = wrappedNode.isOverridable;

	/// Summary: A {WrappedParameterList} containing the parameters of the method.
	public parameters;

	/// Summary: A {WrappedBlock} containing the body of the method, or null if
	///          it has none.
	public body;

	overridable override accept(visitor, arg)
	{
		return visitor.visitMethodDeclaration(this, arg);
	}
}

public class WrappedInvocatorDeclaration is WrappedMethodDeclaration
{
	public new(wrappedNode, annotations, parameters, body)
	{
		new base(wrappedNode, annotations, parameters, body);
	}

	override accept(visitor, arg)
	{
		return visitor.visitInvocatorDeclaration(this, arg);
	}
}

public class WrappedClassConstantDeclaration is WrappedClassMember
{
	public new(wrappedNode, annotations, constants)
	{
		new base(wrappedNode, annotations);

		this.constants = claimAll(constants);
	}

	/// Summary: A {NodeList} containing the {WrappedVariableDeclarator}s
	///          of the class constant declaration.
	public constants;

	override accept(visitor, arg)
	{
		return visitor.visitClassConstantDeclaration(this, arg);
	}
}

public class WrappedIteratorDeclaration is WrappedClassMember
{
	public new(wrappedNode, annotations, body)
	{
		new base(wrappedNode, annotations);

		this.body = body;
	}

	/// Summary: A {Block} containing the body of the iterator.
	public body;

	override accept(visitor, arg)
	{
		return visitor.visitIteratorDeclaration(this, arg);
	}
}

public class WrappedOperatorDeclaration is WrappedClassMember
{
	public new(wrappedNode, annotations, parameters, body)
	{
		new base(wrappedNode, annotations);

		this.parameters = claimAll(parameters);
		this.body       = claim(body);
	}

	/// Summary: Gets the {BinaryOperator} or {UnaryOperator} that this
	///          operator declaration overloads.
	public get op = wrappedNode.op;

	/// Summary: A {WrappedParameterList} containing the parameters of the
	///          operator declaration.
	public parameters;

	/// Summary: Determines whether this operator overloads a unary operator.
	public get isUnary = op is UnaryOperator;

	/// Summary: Determines whether this operator overloads a binary operator.
	public get isBinary = op is BinaryOperator;

	/// Summary: A {WrappedBlock} containing the body of the operator overload declaration.
	public body;

	override accept(visitor, arg)
	{
		return visitor.visitOperatorDeclaration(this, arg);
	}
}

public class WrappedEnumDeclaration is WrappedTypeDeclaration
{
	public new(wrappedNode, annotations, members)
	{
		new base(wrappedNode, annotations);

		this.members = claimAll(members);
	}

	/// Summary: Determines whether the declaration is for an enum set type.
	public get isSet = wrappedNode.isSet;

	/// Summary: A {NodeList} containing the {WrappedEnumMember}s of the enum declaration.
	public members;

	override accept(visitor, arg)
	{
		return visitor.visitEnumDeclaration(this, arg);
	}
}

public class WrappedEnumMember is WrappedNode
{
	public new(wrappedNode, annotations, value)
	{
		new base(wrappedNode);

		this.annotations = claimAll(annotations);
		this.value = claim(value);
	}

	/// Summary: The annotations associated with the enum member,
	///          as a {NodeList} of {WrappedAnnotation} instances.
	public annotations;

	/// Summary: Gets an {Identifier} corresponding to the name of the member.
	public get name = wrappedNode.name;

	/// Summary: The value {WrappedExpression} of this member, or null if there is none.
	public value;

	override accept(visitor, arg)
	{
		return visitor.visitEnumMember(this, arg);
	}
}

public class WrappedVariableDeclarator is WrappedNode
{
	public new(wrappedNode, initializer)
	{
		new base(wrappedNode);

		this.initializer = claim(initializer);
	}

	/// Summary: Gets an {Identifier} corresponding to the declared name
	///          of the variable.
	public get name = wrappedNode.name;

	/// Summary: The initializer {WrappedExpression} of the variable, or null if
	///          the declarator has no initializer.
	public initializer;

	override accept(visitor, arg)
	{
		return visitor.visitVariableDeclarator(this, arg);
	}
}

public inheritable WrappedParameter is WrappedNode
{
	public new(wrappedNode, defaultValue)
	{
		new base(wrappedNode);

		this.defaultValue = claim(defaultValue);
	}

	/// Summary: Gets an {Identifier} corresponding to the name of the parameter.
	public get name = wrappedNode.name;

	/// Summary: The {WrappedExpression} that makes up the default value of
	///          the parameter, or null if the parameter is not optional.
	public defaultValue;

	/// Summary: Determines whether the parameter is optional.
	public get isOptional = wrappedNode.isOptional;

	/// Summary: Determines whether the parameter is variadic.
	public get isVariadic = wrappedNode.isVariadic;

	/// Summary: Determines whether the parameter is passed by reference.
	public get isRef = wrappedNode.isRef;

	public get hasThisPrefix = wrappedNode.hasThisPrefix;

	overridable override accept(visitor, arg)
	{
		return visitor.visitParameter(this, arg);
	}
}

public class WrappedThisParameter is WrappedParameter
{
	public new(wrappedNode, defaultValue)
	{
		new base(wrappedNode, defaultValue);
	}

	override accept(visitor, arg)
	{
		return visitor.visitThisParameter(this, arg);
	}
}

public class WrappedGlobalVariableDeclaration is WrappedLocalDeclaration
{
	public new(wrappedNode, declaration)
	{
		new base(wrappedNode);

		this.declaration = claim(declaration);
	}

	/// Summary: The {WrappedSimpleLocalVariableDeclaration} or {WrappedParallelLocalVariableDeclaration}
	///          that this global variable declaration wraps.
	public declaration;

	override accept(visitor, arg)
	{
		return visitor.visitGlobalVariableDeclaration(this, arg);
	}
}

public class WrappedAnnotation is WrappedNode
{
	public new(wrappedNode, type, positionalArguments, namedArguments)
	{
		new base(wrappedNode);

		this.type = claim(type);
		this.positionalArguments = claimAll(positionalArguments);
		this.namedArguments = claimAll(namedArguments);
	}

	/// Summary: Determines whether the annotation is targeted at the module, rather
	///          than at a member.
	public get isGlobal = wrappedNode.isGlobal;

	/// Summary: The {WrappedTypeName} of the annotation type.
	public type;

	/// Summary: A {WrappedArgumentList} containing the positional arguments
	///          of this annotation.
	public positionalArguments;

	/// Summary: A {NodeList} containing the named arguments of this annotation,
	///          represented by {WrappedMemberInitializer}s.
	public namedArguments;

	override accept(visitor, arg)
	{
		return visitor.visitAnnotation(this, arg);
	}
}
