use namespace aves;
use namespace io;
use namespace osprey.compiler;
use namespace osprey.compiler.parser;

namespace osprey.errorCodeGen;

function main(args)
{
	if args.length < 2
	{
		print("Usage:  errorCodeGen.ovm  <message file> <template file> <output file>");
		print("<message file> contains the file with messages;");
		print("<template file> contains the {$errorCodes$} placeholder;");
		print("and <output file> becomes the generated file.");
		return 1;
	}

	var (msgFile, templFile, outFile) = args;

	var messages = readMessages(SourceFile.open(msgFile, false));
	var template = File.readAllText(templFile);
	template = template.split("{$errorCodes$}");
	with writer = TextWriter.open(outFile)
	{
		writer.newline = "\n"; // Always use Unix line endings

		writer.write(template[0]);

		for msg in messages:
			writer.writeLine("\tpublic const {0} = {1};".format(msg));

		writer.write(template[1]);
	}

	print("Generated {0} error codes.", [messages.length]);
}

function readMessages(file)
{
	var messages = [];

	var parser = new Parser(file, ParseFlags.none);
	// The message file uses Osprey tokens, according to the following grammar:
	//   message-file:
	//     messages
	//   messages:
	//     message
	//     messages  message
	//   message:
	//     integer-literal  identifier  '='  string-literal  ';'
	// With the additional restriction that the integer literal must be of
	// type aves.Int. Unsigned integers are not allowed.
	// We only use the identifier and integer-literal. The string literal
	// is used by the ErrorCode class.

	var i = 0;
	while not parser.accept(i, TokenType.eof)
	{
		var code = parser.expectr(ref i, TokenType.int).sourceText;
		var name = parser.expectr(ref i, TokenType.identifier).sourceText;

		parser.expectr(ref i, TokenType.assign);
		parser.expectr(ref i, TokenType.string);
		parser.expectr(ref i, TokenType.semicolon);

		messages.add([name, code]);
	}

	return messages;
}
